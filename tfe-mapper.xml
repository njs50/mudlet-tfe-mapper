<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="yes" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>filter broken prompts</name>
			<script>if (rex.find(matches[1], [[^&lt;]])) then
  -- echo(' &lt;- prompt\n')
  raiseEvent(njs50.scanner.events.PROMPT)
 end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(?:&lt;[^&gt;]+&gt;\s*)?([^&lt;].*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>scanner</name>
				<script>
-- You see nothing in the vicinity.
if (matches[1] == 'You see nothing in the vicinity.') then
	
		-- echo(' &lt;-- reset exits')
  	njs50.scanner.resetExits();
		cecho(' &lt;- &lt;green&gt;SCANNER: &lt;white&gt;clear\n')
		raiseEvent(njs50.scanner.events.SCAN_PROCESSED)
		
else 

  local direction = matches[2]:gsub('^%s+','')
  
  if (direction ~= '' or njs50.scanner.scan_in_progress) then
  
    if (matches[3] == 'darkness') then
      cecho('\n&lt;orange&gt;SCANNER: &lt;white&gt;should create better light before continuing\n')    
    else			
  		
      -- sometimes scan is jammed in with other content. scan lines are always indented with spaces
      -- so matches[2] should either be a bunch of space or a direction
      if (matches[3] ~= '' and matches[2] ~= '') then
  		  njs50.scanner.scannedLine(direction, matches[3])
      else
        -- scanning done, no need to wait for prompt (in case there is other junk before it)
        njs50.scanner.endScan()        
      end
  	 	
    end 
  
  end
		
 end -- end (if you see nothing)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(north|east|south|west|up|down|\[Here\])\s+:\s+(.+)$</string>
					<string>^(\s*)(.*)$</string>
					<string>You see nothing in the vicinity.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>rescan if something died</name>
				<script>send('scan')

--       A fair gnomish lass is DEAD!!</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(An?|The) (.*) is DEAD!!</string>
					<string>^(An?|The) (.*) blindly flees </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You can't do that while mounted.</name>
				<script>njs50.onNextEvent(tfe.events.ROOM_CHANGED, function ()
	send('mount')
end)
send('dismount')
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't do that while mounted.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>The x to the y is closed.</name>
				<script>disableTrigger('The x to the y is closed.')

local vic = njs50.dotCase(njs50.toMurderString(matches[2]))

-- convert north gate etc -&gt; gate
vic = rex.gsub(vic, '(north|east|south|west|down|up|above|below).', '') 

local dir = matches[3]

send('move beam &amp; pull lever &amp; turn crank &amp; pull cord')
send('unlock ' .. vic .. ' &amp; unlock ' .. dir)
send('open ' .. vic .. ' &amp; open ' .. dir)
send('knock ' .. vic .. ' &amp; knock ' .. dir)
send('pound ' .. vic .. ' &amp; pound ' .. dir)

tempTimer(2, function () send('scan') end, 'scan after attempting to open')

tempTimer(1, function ()
	enableTrigger('The x to the y is closed.')
end, 'reenable closed door trig')

if (tfe.speedwalking) then
	send(tfe.lastMoveDirection)
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^The (.+) to the (.+) (is|are) closed.</string>
					<string>^Perhaps you should open the (double) (doors)</string>
					<string>^The (.*) (below|above) you (is|are) closed.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>no exit - use special exit</name>
				<script>disableTrigger('no exit - use special exit')

local exit = matches[2]

if (exit == 'below') then exit = 'down' end
if (exit == 'above') then exit = 'up' end



local exits = getRoomExits(tfe.roomInfo.vnum)
local specialExits = getSpecialExits(tfe.roomInfo.vnum)

if (exits and specialExits) then

  local targetRoom = exits[exit]
  
  if (targetRoom and specialExits[targetRoom]) then
    for command, idx in pairs(specialExits[targetRoom]) do 
      send(command)
    end
  else
    cecho('\n&lt;green&gt;MOVE: &lt;white&gt;failed to go ' .. exit .. '... you can use "map exit [n|e|s|w|u|d] &lt;cmd&gt;" to add a special exit \n' )
  end

else
  cecho('\n&lt;green&gt;MOVE: &lt;white&gt;failed to go ' .. exit .. '... you can use "map exit [n|e|s|w|u|d] &lt;cmd&gt;" to add a special exit \n' )
end

tempTimer(1, function ()
	enableTrigger('no exit - use special exit')
end, 'reenable closed door trig')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You see no exit to the (.*)\.</string>
					<string>^You see no exit (.*) you\.</string>
					<string>^The .+ to the (.+) (is|are) closed.</string>
					<string>^The .* (below|above) you (is|are) closed.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>map reset</name>
			<script>local commands = {
  
  reset = function(thing)
    if (thing == 'area') then
      tfe.deleteCurrentMapArea()
    end
  end,
  
  update = njs50.update_mapper,
  
}

if (commands[matches[2]]) then
  commands[matches[2]](matches[3])
else
  cecho('&lt;red&gt;TFE MAP: &lt;white&gt;unknown command - ' .. matches[2] .. '\n\n')
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map (reset|update)\s?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>go</name>
			<script>local dest = matches[2]

tfe.locations = tfe.locations or {}

local rnum = tfe.locations[dest] or dest

if (type(rnum) == 'string' and rnum:match([[^%d+$]])) then
  rnum = tonumber(rnum)
end

if (type(rnum) == 'number' and roomExists(rnum)) then

	cecho('&lt;green&gt;TFE MAP:&lt;white&gt; going to ' .. getRoomName(rnum) .. '\n')
 
  local endCmd = matches[3]

	tfe.gotoRoom(rnum, { 
    callback = function () 
  		if (endCmd) then
  			expandAlias(endCmd)
  		end
  	end
  })
	
else
	cecho('\n&lt;red&gt;TFE MAP:&lt;white&gt; Invalid speed walk location\n')
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^go (\S+)\s?&amp;?\s?(.*)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>^(stop|pause|resume)$</name>
			<script>
local commands = {
  stop = tfe.speedwalkStop,
  pause = tfe.speedwalkPause,
  resume = tfe.speedwalkResume,
}

commands[matches[2]]()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(stop|pause|resume)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - special exit</name>
			<script>local dir = matches[2]
local cmd = matches[3]

-- cancel an existing special exit if the move failed (maybe we were in the wrong room)
if (dir ~= 'cancel') then
  
  if (tfe.pendingSpecialExit) then
    tfe.pendingSpecialExit()
  end
  
  tfe.pendingExit = {
    direction = tfe.consts.reverse_dirs[tfe.consts.exitmap[dir]],
    vnum = tfe.roomInfo.vnum
  }
   
  
  tfe.pendingSpecialExit = njs50.onNextEvent(tfe.events.ROOM_CHANGED, function () 
  
    addSpecialExit(tfe.previousRoomInfo.vnum, tfe.roomInfo.vnum, cmd)
    setExit(tfe.previousRoomInfo.vnum, tfe.roomInfo.vnum, dir)
    setExitWeight(tfe.previousRoomInfo.vnum, dir, 3)
      
    tfe.pendingSpecialExit = nil
    tfe.pendingExit = nil
  
  end)
  
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; adding special exit!\n')
  cecho('&lt;green&gt;TFE MAP: &lt;white&gt; type "map exit cancel" to cancel if the command fails to change the room!\n')
  send(cmd)

else

  if (tfe.pendingSpecialExit) then
    tfe.pendingSpecialExit()
  end
  
  tfe.pendingExit = nil
  cecho('\n&lt;yellow&gt;TFE MAP: &lt;white&gt; cancelled adding special exit!\n')

end</script>
			<command></command>
			<packageName></packageName>
			<regex>^map exit (n|e|s|w|u|d|in|out|cancel) ?(.*)$</regex>
		</Alias>
		<Alias isActive="no" isFolder="no">
			<name>map - manual connect existing rooms by id</name>
			<script>-- not sure we need this anymore, only really useful for retroactively connecting things

local dir = matches[2]
local room1 = tonumber(matches[3])
local room2 = tonumber(matches[4])
local cmd = matches[5] or ''


if (roomExists(room1) and roomExists(room2)) then
  
  addSpecialExit(room1, room2, cmd)
  setExit(room1, room2, dir)
  setExitWeight(room1, dir, 3) -- prioritize special exit
  
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; connecting existing rooms with special exit!\n')
  
else
  
  if not roomExists(room1) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; room doesn\'t exist in map!: ' .. tostring(room1) .. '\n')
  else
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; room doesn\'t exist in map!: ' .. tostring(room2) .. '\n')
  end

end
</script>
			<command></command>
			<packageName></packageName>
			<regex>^map connect (n|e|s|w|u|d|in|out) (\d+) (\d+) ?(.*)?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>map - connect current room with previous</name>
			<script>

local dir = matches[2]
local cmd = matches[3]

local room1 = tfe.roomInfo.vnum
local room2 = tfe.previousRoomInfo.vnum


  -- we may need to create the current room if it is orphaned in the zone from the prev room
  if not roomExists(room1) then
  
    local areaId = tfe.getAreaID(tfe.roomInfo)
     
    local x,y,z = tfe.getRoomCoordinatesByExit(room2, tfe.consts.exitmap[dir])
    
    -- echo('\new location is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
        
      addRoom(tfe.roomInfo.vnum)
		  setRoomArea(tfe.roomInfo.vnum, areaId);
  	  setRoomName(tfe.roomInfo.vnum, tfe.roomInfo.name)
  	  setRoomCoordinates(tfe.roomInfo.vnum, x, y, z)  
      centerview(tfe.roomInfo.vnum)
      
      cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; added new room - ' .. dir .. ' from ' .. tfe.previousRoomInfo.name .. '\n')
  
  end




if (roomExists(room1) and roomExists(room2)) then
  
  setExit(room2, room1, dir)
  
  if (cmd) then        
    addSpecialExit(room2, room1, cmd) 
    setExitWeight(room2, dir, 3) -- prioritize special exit
  end
  
  setExit(room2, room1, dir)
  centerview(room1)
    
  cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt; connecting existing rooms!\n')
  
else

  cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; room doesn\'t exist in map!: ' .. tostring(room2) .. '\n')

end
</script>
			<command></command>
			<packageName></packageName>
			<regex>^map connect (n|e|s|w|u|d|in|out) ?(.*)$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>configuration</name>
			<packageName></packageName>
			<script>njs50 = njs50 or {}
njs50.config = {

  rewrite_scan = false, -- make scan results clickable (move or attack)

}






njs50.update_mapper = function ()

  local URL = "https://raw.githubusercontent.com/njs50/tfe-mapper/master/tfe-mapper.xml"
  
  njs50.onNextEvent("sysDownloadDone", function (_, f)
    if not f:find("tfe-mapper", 1, true) then 
      return 
    end
    uninstallPackage("tfe-mapper")
    installPackage(f)
    os.remove(f)
    cecho("&lt;lime_green&gt;Package installed!\n") 
  end)
  
  downloadFile(getMudletHomeDir()..(URL:ends("xml") and "/tfe-mapper.xml" or "/tfe-mapper.zip"), URL)

end

njs50.install_color_theme = function ()



end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>njs50 common</name>
			<packageName></packageName>
			<script>njs50 = njs50 or {}

njs50.onNextEvent = function (evt, callback)

	if not evt then
		cecho('\n\n&lt;red&gt;Next Event: &lt;white&gt;no event defined!!!\n\n')
		error()
	end


	local handlerId = nil
	local cb2 = callback

	local cb = function (evt, args)
		killAnonymousEventHandler(handlerId)
		cb2(evt, args)
	end

	handlerId = registerAnonymousEventHandler(evt, cb, true)

	-- cecho('\n&lt;green&gt;registering self destruct event: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')

	return function ()
		-- cecho('\n&lt;orange&gt;destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		killAnonymousEventHandler(handlerId)
	end

end

njs50.tablelength = function(T)
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>formatters</name>
			<packageName></packageName>
			<script>

njs50.getNumber = function (text)

	local wordToNumberData = {
  	a = 1,
  	an = 1,
  	the = 1,
		one = 1,
		two = 2,
		three = 3,
		four = 4,
		five = 5,
		six = 6,
		seven = 7,
		eight = 8,
		nine = 9,
		ten = 10,
		eleven = 11,
		twelve = 12,
		thrirteen = 13,
		fourteen = 14,
    fifteen = 15,
	}

	local numTxt = rex.match(text, [[^\S+]])

	if (numTxt) then
		return wordToNumberData[string.lower(numTxt)] or 1
	else
		-- either it's more than 14 or a proper noun. i.e Stinky (your mount
		return 1
	end

end

njs50.tableToString = function (table)
  
  local list = ''
  
  for idx, val in ipairs(table) do
    
    list = list .. val .. ', '
  
  end
  
  list = list:gsub(', $', '')
  
  return list
  
end

njs50.dotCase = function(string)

	if (not string or string == '') then
		return ''
	end
	return rex.gsub(string, [[\b(the|or|an|a|of|with|and|A|An|The) ]], ''):gsub(' ', '.')
end


njs50.itemSanitize = function(string)

	if (not string or string == '') then
		return ''
	end
	return rex.gsub(string, [[(enchanted |empty, |flaming, frost-covered |flaming |frost-covered |labeled |empty |\s\+\d)]], '')
end

njs50.itemShorten = function(item)

  return rex.gsub(
		rex.gsub(common.dotCase(common.itemSanitize(item)),"'(.*)'",'%1'), 
		'([^.][^.][^.][^.]?)[^.]+', 
		'%1'
	)
	
end

njs50.commaCase = function (str)
    local extra = #str%3
    if string.sub(str,1,1) == "-" then
        if extra == 0 then
            extra = 3
        else
            extra = extra + 1
        end
    end
    local result = ""
    if extra &gt; 0 then
        result = string.sub(str,1,extra)
        str = string.sub(str,extra+1)
    end
    for w in string.gmatch(str,"%d%d%d") do
        result = result .. "," .. w
    end
    return result:gsub([[^,?]],'')
end



njs50.toMurderString = function (victim)

	-- remove any articles etc
	victim = rex.gsub(victim, [[\b(a|an|the|good|evil|The|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen)\s]], '')


	-- dump any random commas
	victim = rex.gsub(victim, [[,]], '')
  
	-- turn elves back into elf, dwarves etc
	victim = rex.gsub(victim, [[ves$]], 'f')

	-- turn women back to womans
	victim = rex.gsub(victim, [[women\b]], 'woman')

	-- drop i from end (plurals like homonculi
  local ignoreTerminalI = {
    yeti = true
  }
  
  if (not ignoreTerminalI[victim]) then
	 victim = rex.gsub(victim, [[i\b]], '')
  end



  -- remove as many suffixes as we can, don't bother trying to replace them
  
  victim = rex.gsub(victim, [[([bcdfghjklmpqrstvwxz])ies\b]], '%1')

	victim = rex.gsub(victim, [[(s|sh|ch|x|z)es\b]], '%1')
  
  victim = rex.gsub(victim, [[('?s'?)\b]], '')

	-- kill any parts less than 3 charaters
	victim = rex.gsub(victim, [[(^|\.|\s)\S\S?(\s|\.|$)]], '%1%2')

	-- kill any extra whitepsace or multiple .'s
	victim = rex.gsub(victim, [[(\s\s+|\.\.+)]], ' ')
	victim = string.trim(victim)

	-- kill any . at start or end.
	victim = rex.gsub(victim, [[^\.]], '')
	victim = rex.gsub(victim, [[\.$]], '')

	return victim

end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>scanner</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

njs50.scanner = njs50.scanner or {}

njs50.scanner.events = {		
	SCAN_PROCESSED = 'SCANNER:rooms_scanned',
  PROMPT = 'SCANNER:prompt seen',
}

njs50.scanner.resetExits = function ()
	njs50.scanner.exits = {}
end


njs50.scanner.resetScanner = function ()
	njs50.scanner.scan_in_progress = false
  njs50.scanner.currentDirection = nil
	if (njs50.scanner.cancel_scan_in_progress) then
		njs50.scanner.cancel_scan_in_progress()
		njs50.scanner.cancel_scan_in_progress = nil
	end
	njs50.scanner.resetExits()
end

njs50.scanner.endScan = function()
  if (njs50.scanner.cancel_scan_in_progress) then
    njs50.scanner.cancel_scan_in_progress()
    njs50.scanner.cancel_scan_in_progress = nil
  end
  njs50.scanner.currentDirection = nil
  njs50.scanner.scan_in_progress = false
  cecho(' &lt;- &lt;green&gt;SCANNER: &lt;white&gt;scan ended\n')

  -- display(njs50.scanner.exits)
	raiseEvent(njs50.scanner.events.SCAN_PROCESSED)
end

njs50.scanner.scannedLine = function (direction, mobs)  		
	
	if (not njs50.scanner.scan_in_progress) then
    -- cecho('\n&lt;green&gt;SCANNER: &lt;white&gt;scan started\n')
		njs50.scanner.resetExits();			
		njs50.scanner.scan_in_progress = true
    -- in case for some reason there isn't a blank line after the scan
    -- stop scanning ont the next prompt
		njs50.scanner.cancel_scan_in_progress = njs50.onNextEvent(njs50.scanner.events.PROMPT, njs50.scanner.endScan)
	end
  
	
  if (direction ~= "") then
    njs50.scanner.processingExit = direction
    
    if (direction ~= '[Here]') then
      if njs50.config.rewrite_scan then
        selectString(direction,1)
        setUnderline(true)
        setLink([[send("]]..direction..[[")]], 'move ' .. direction)
        resetFormat()
      end
    end
    
  else
     direction = njs50.scanner.processingExit
  end
  
  njs50.scanner.exits[direction] = njs50.scanner.exits[direction] or {}
  
  -- convert strings to individual mobs
  -- nb: commas make this difficult as they might be in a mob name and not a seperator
  -- i.e. 
  
  
  local nubs = {}
  for s, c, r in rex.split(mobs, [[, (?=a |an |the |[A-Z]|two |three |four |five |six |seven |eight |nine |ten |eleven |twelve | thirteen |fourteen |fifteen )]]) do
    table.insert(nubs, s)
  end
  
  -- convert mobs to attack strings with counts
  for idx, mobString in pairs(nubs) do
    
    local mobRecord
    local ks = njs50.dotCase(njs50.toMurderString(mobString))
    local count = njs50.getNumber(mobString)
    
    -- check to see if there is already a mob with this name
    -- i.e east: a Medienne Knight, a Medienne Knight
    for idx, record in pairs(njs50.scanner.exits[direction]) do
      if (record.killString == ks) then
        mobRecord = record
        break;
      end
    end
    
    if (mobRecord == nil) then 
      mobRecord = { 
        raw = mobString, 
        killString = ks, 
        count = count 
      }
      table.insert(njs50.scanner.exits[direction], mobRecord)
    else
      mobRecord.count = mobRecord.count + count
    end
      
    if njs50.config.rewrite_scan then  
      selectString(mobRecord.raw,1)
      setUnderline(true)
      setLink([[send("]].. direction ..[[ &amp; k ]] .. mobRecord.killString .. [[")]], direction .. ' &amp; k ' .. mobRecord.killString)
      -- replace('xxxx')
      resetFormat()
    end
    
  end
	
end

</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>tfe mapper</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
mudlet = mudlet or {};
mudlet.mapper_script = true



tfe = tfe or {}

tfe.events = {
  ROOM_CHANGED = 'tfe mapper: room found',
  WALK_COMPLETE = 'tfe mapper: speedwalk complete',
}

-- bleh 1-16 and 257-272 are reserved
tfe.environment = {
  
  Air = 41,
  ["Magical Cloud"] = 59,
  
  
  ["Dark Bamboo"] = 47, 
  ["Bamboo Forest"] = 42,
  Forest = 53,
  Jungle = 56,
  Rainforest = 25,
  Tree = 34, 
   
  Trail = 33, 
  ["Jungle Trail"] = 57,
  ["Forest Path"] = 54,
  
  Dirt = 49,

  ["Compost Zone"] = 46,
  
  Dump = 51,
  Pudding = 24,
  
  Path = 23,
  Road = 27,
  ["Town Street"] = 32,
    
  Tundra = 35, 
  Field = 52,
  
  Beach = 43,
  Desert = 48,
  ["White Sand"] = 39,
   
  Cave = 45,
 
  Lava = 58,
  
  Hills = 55,

  Bridge = 44,
  Mountain = 20,
  
  Underwater = 36,
  Water = 38,
  River = 26,
  ["Ocean Water"] = 22,

  Swamp = 31,
  
  Shallows = 29,
  ["Dry Riverbed"] = 50,
  
  Shipboard = 30,
  WoodenBoards = 40,
  
  Room = 28,
  
  Nondescript = 21,
  Void = 37,
  
}


-- to see color optiosn
-- lua showColors(3)

tfe.environmentColor = {
  
  Air = 'deep_sky_blue',
  ["Magical Cloud"] = 'light_sky_blue',
  
  
  ["Dark Bamboo"] = 'dark_green', 
  
  ["Bamboo Forest"] = 'forest_green',
  Forest = 'forest_green',
  Jungle = 'forest_green',
  Rainforest = 'forest_green',
  Tree = 'lime_green',
   
  Path = 'khaki', 
  Trail = 'khaki', 
  ["Jungle Trail"] = 'khaki', 
  ["Forest Path"] = 'khaki', 
  
  Dirt = 'saddle_brown', 

  ["Compost Zone"] = 'saddle_brown',
  
  Dump ='saddle_brown',
  Pudding = 'saddle_brown',
  
  
  
  Road = 'dark_khaki',
  ["Town Street"] = 'dark_khaki',
    
  Tundra = 'wheat', 
  Field = 'wheat', 
  
  Beach = 'navajo_white',
  Desert = 'navajo_white',
  ["White Sand"] = 'navajo_white',
   
  Cave = 'dark_slate_gray',
 
  Lava = 'orange_red',
  
  Hills = 'dark_olive_green',

  Bridge = 'dark_olive_green',
  Mountain = 'dark_olive_green',
  
  Underwater = 'navy_blue',
  
  Water = 'dodger_blue',
  River = 'dodger_blue',
  ["Ocean Water"] = 'dodger_blue',

  Swamp = 'light_sky_blue',
  
  Shallows = 'light_sky_blue',
  
  ["Dry Riverbed"] = 'light_steel_blue',
  
  Shipboard = 'dark_khaki',
  WoodenBoards = 'dark_khaki',
  
  Room = 'beige',
  
  Nondescript = 'beige',
  
  Void = 'dark_slate_grey',
  
}

for terrain, color in pairs(tfe.environmentColor) do
  local r, g, b = unpack(color_table[color])
  setCustomEnvColor(tfe.environment[terrain], r, g, b, 255)
end


local shortSpeedWalkTimerId

tfe.startShortSpeedWalkTimer = function ()

	-- clear any existing timer
	tfe.clearShortSpeedWalkTimer()


	-- give us 5 seconds to move...
	shortSpeedWalkTimerId = tempTimer(5, function ()
		shortSpeedWalkTimerId = nil
		cecho('\n&lt;yellow&gt;TFE MAP: &lt;white&gt;5 seconds without room change!!! - updating path...\n')
		tfe.rerouteSpeedwalk()
    tfe.speedWalkStep()
	end)


end

tfe.clearShortSpeedWalkTimer = function()
	if (shortSpeedWalkTimerId) then
		killTimer(shortSpeedWalkTimerId)
	end
	shortSpeedWalkTimerId = nil
end

tfe.speedwalkPause = function ()
  if (tfe.speedwalking) then
    tfe.speedwalking.paused = true
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking paused\n')
  else
   cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;not currently speedwalking\n')
  end
end

tfe.speedwalkResume = function ()
  if (tfe.speedwalking) then
    tfe.speedwalking.paused = nil
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking resumed\n')
    tfe.speedWalkStep()
  else
     cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;not currently speedwalking\n')
  end
end

tfe.speedwalkStop = function ()
 
 if (tfe.speedwalking) then
    tfe.clearShortSpeedWalkTimer()
    -- clear any room change watcher if it exists
    if (tfe.speedwalking.roomChangeWatcher) then
      tfe.speedwalking.roomChangeWatcher()
      tfe.speedwalking.roomChangeWatcher = nil
    end
    
    tfe.speedwalking = nil
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking stopped\n')
  else
     cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;not currently speedwalking\n')
  end
  
end


tfe.speedWalkStep = function ()
  
  tfe.clearShortSpeedWalkTimer()
  -- clear any room change watcher if it exists
  if (tfe.speedwalking.roomChangeWatcher) then
    tfe.speedwalking.roomChangeWatcher()
    tfe.speedwalking.roomChangeWatcher = nil
  end

  if (tfe.speedwalking) then
    
    
    -- check we are not off course...
    local nextStep = tfe.getNextStep()

    if (nextStep == nil) then
      
      -- we made it to the end. call the callback if it exists
      cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;at destination\n')
      if (tfe.speedwalking.options and tfe.speedwalking.options.callback) then
        tfe.speedwalking.options.callback()
      end
      
      tfe.speedwalking = nil
      raiseEvent(tfe.events.WALK_COMPLETE)
    
    else
    
      -- we are where we should be. send a move etc
      
      if (not tfe.speedwalking.paused) then
      
        -- setup a single event watcher for a room change
        tfe.speedwalking.roomChangeWatcher = njs50.onNextEvent(tfe.events.ROOM_CHANGED, function() 
          -- step completed. do next step    
          tfe.speedWalkStep()
        end)
        
        tfe.startShortSpeedWalkTimer()

        -- send command
        if(nextStep and nextStep ~= '') then
          send( nextStep )    
          tfe.advanceStepPosition()
        else
          cecho('\n\n&lt;red&gt;TFE MAP: &lt;white&gt;unsure  how to progress (missing special exit?)\n')
        end
        
      else
        cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;speedwalking paused\n')
      end
    
    end
      
      
    
    
  else
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unable to update path., destination not in map\n')
  end

end

tfe.getNextStep = function (reverse)

  -- not currently walking anywhere
  if (not tfe.speedwalking) then
    return nil
  end
  
  -- at destination
  if (not reverse and tostring(tfe.roomInfo.vnum) == tfe.speedwalking.destination) then
    return nil
  end
  
  -- at start and reversed
  if (reverse and tfe.speedwalking.pathPosition == 1) then
    return nil
  end
  
  -- check if we are lost and need to reroute...  
  if (tostring(tfe.roomInfo.vnum) ~= tfe.speedwalking.path[tfe.speedwalking.pathPosition]) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;we are off the designated path, recalculating in 5 seconds\n')
    tfe.rerouteSpeedwalk()
  end
  
  if (not reverse) then

    return tfe.consts.exitmap[ tfe.speedwalking.directions[tfe.speedwalking.pathPosition] ] or tfe.speedwalking.directions[tfe.speedwalking.pathPosition]      
  
  else
  
    local specialExits = getSpecialExits(tfe.roomInfo.vnum)
    local targetRoom = tonumber(tfe.speedwalking.path[tfe.speedwalking.pathPosition - 1])
    
    local cmd = ''
    
    if (specialExits and specialExits[targetRoom]) then
      for command, idx in pairs(specialExits[targetRoom]) do 
        cmd = cmd .. command .. ' &amp; '
      end
      cmd = cmd:gsub([[ &amp; $]], '')
      
    else
      cmd = tfe.consts.reverse_dirs[ tfe.consts.exitmap[ tfe.speedwalking.directions[tfe.speedwalking.pathPosition - 1] ] ]
    end
    
    return cmd  
  
  end
  
end

tfe.getNextDirection = function (reverse)

  -- not currently walking anywhere
  if (not tfe.speedwalking) then
    return nil
  end
  
  -- at destination
  if (not reverse and tostring(tfe.roomInfo.vnum) == tfe.speedwalking.destination) then
    return nil
  end
  
  -- at start and reversed
  if (reverse and tfe.speedwalking.pathPosition == 1) then
    return nil
  end
  
    -- check if we are lost and need to reroute...  
  if (tostring(tfe.roomInfo.vnum) ~= tfe.speedwalking.path[tfe.speedwalking.pathPosition]) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;we are off the designated path, recalculating in 5 seconds\n')
    tfe.rerouteSpeedwalk()
  end
  
  local nextpos = tfe.speedwalking.pathPosition
    
  if (reverse) then
    nextpos = nextpos - 1
  else
    nextpos = nextpos + 1
  end
  
  local target = tonumber(tfe.speedwalking.path[nextpos])
  local exits = getRoomExits(tfe.roomInfo.vnum)
      
  for dir, vnum in pairs(exits) do
    if (vnum == target) then 
      direction = dir
      break;
    end
  end
  
  return direction
  
end


tfe.advanceStepPosition = function (reverse)

  -- at destination
  if (not reverse and tfe.speedwalking.pathPosition &gt; #tfe.speedwalking.directions ) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;attempted to step beyond end of path\n')
    return nil
  end
  
  -- at start and reversed
  if (reverse and tfe.speedwalking.pathPosition == 1) then
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;attempted to reverse step below start of path\n')
    return nil
  end

  if(tfe.speedwalking) then
    if (not reverse) then
      tfe.speedwalking.pathPosition = tfe.speedwalking.pathPosition + 1
    else
      tfe.speedwalking.pathPosition = tfe.speedwalking.pathPosition - 1
    end
  end
end


tfe.rerouteSpeedwalk = function ()
  if (tfe.speedwalking) then 
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;rerouting speedwalk\n')
    if (tfe.speedwalking.roomChangeWatcher) then
      tfe.speedwalking.roomChangeWatcher()
      tfe.speedwalking.roomChangeWatcher = nil
    end
    tfe.configureWalkPath(tfe.speedwalking.destination, tfe.speedwalking.options)
  end
end


tfe.configureWalkPath = function (vnum, options)

  tfe.speedwalking = nil
  
  vnum = tostring(vnum)

  cecho('&lt;green&gt;pathing: &lt;white&gt;' .. tostring(tfe.roomInfo.vnum) .. ' to ' .. tostring(vnum))
	if (roomExists(tfe.roomInfo.vnum)) then
  	if (roomExists(tfe.roomInfo.vnum)) then
    
      getPath(tfe.roomInfo.vnum, vnum)
    
      tfe.speedwalking = {
        destination = vnum,
        path = speedWalkPath,
        directions = speedWalkDir,
        pathPosition = 1,
        options = options or {}
      }
    
      table.insert(tfe.speedwalking.path, 1, tostring(tfe.roomInfo.vnum))
      
     else
     
  		cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unable to update path., destination not in map\n')
  	end
  	
	else
		cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unable to update path., current room not in map\n')
	end

end



tfe.gotoRoom = function (vnum, options)
  
  if (type(options) == 'function') then
    local optCB = options
    options = {callback = optCB}
  elseif (type(options) == 'string') then
    local optString = options 
    options = {callback = function() send(optString) end}
  else
    if (options ~= nil) then
      cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt;unknown options provided to tfe.gotoRoom\n')
    end
    options = {}
  end
  
  tfe.configureWalkPath(vnum, options)
  
  if (tfe.speedwalking) then
    tfe.speedWalkStep()
  end

end


-- to allow clicking the map
function doSpeedWalk()
 	tfe.gotoRoom(speedWalkPath[#speedWalkPath])
end


 </script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>tfe.room_info_update</name>
			<packageName></packageName>
			<script>tfe = tfe or {}

tfe.consts = tfe.consts or {}

tfe.consts.exitmap = {
    n = 'north',    e = 'east',
    w = 'west',     s = 'south',
    u = 'up',       d = 'down',
	  N = 'north',    E = 'east',
    W = 'west',     S = 'south',
    U = 'up',       D = 'down',
    ["in"] = 'in',  out = 'out',
}


tfe.consts.short = {}
for k,v in pairs(tfe.consts.exitmap) do
    tfe.consts.short[v] = k
end

-- for some reason the speed walker doesn't use shorts for up/down
tfe.consts.exitmap['up'] = 'up'
tfe.consts.exitmap['down'] = 'down'

tfe.consts.stubmap = {
    north = 1,      east = 4,
    west = 5,       south = 6,
    up = 9,         down = 10,          
    ["in"] = 11,    out = 12,
    [1] = "north",  [4] = "east",
    [5] = "west",   [6] = "south",
    [9] = "up",     [10] = "down",
    [11] = "in",    [12] = "out",
}

-- in case an in/out goes to the same zone send it/down 100 layers so it doesn't overlap with an existing exit
tfe.consts.coordmap = {
    [1] = {0,1,0},      [4] = {1,0,0},
    [5] = {-1,0,0},     [6] = {0,-1,0},
    [9] = {0,0,1},      [10] = {0,0,-1},
    [11] = {0,0,100},     [12] = {0,0,-100}
}

tfe.consts.reverse_dirs = {
    north = "south", south = "north",
		west = "east", east = "west",
		up = "down", down = "up",
    ["in"] = "out", out = "in",
}




tfe.room_info_update = function()
  
  -- only proceed if there is actually room info
  if (gmcp.Room.Info.area_id and gmcp.Room.Info.vnum) then
    
    if (tfe.roomInfo) then
    
      tfe.previousRoomInfo = tfe.roomInfo
      tfe.roomInfo = gmcp.Room.Info
      
      tfe.lastMoveDirection = ''
      
      for exit, vnum in pairs(getRoomExits(tfe.previousRoomInfo.vnum)) do
        if (vnum == gmcp.Room.Info.vnum) then
          tfe.lastMoveDirection = exit
          break
        end
      end
      
      if (tfe.lastMoveDirection == '') then
        for exit, vnum in pairs(tfe.roomInfo.exits) do
          if (vnum == tfe.roomInfo.vnum) then
            tfe.lastMoveDirection = tfe.consts.reverse_dirs[exit]
            break
          end
        end
      end
     
     -- cecho('\n&lt;green&gt;SPEEDWALK: &lt;white&gt;last move dir: ' .. tfe.lastMoveDirection ..'\n')
     
    else
      
      -- this is the first room for this session!
      tfe.roomInfo = gmcp.Room.Info 

    end -- end if has room info
    
    
    -- display(tfe.roomInfo)
    
    local areaId = tfe.getAreaID(tfe.roomInfo)
    
    -- if existing room center map on it
    if (not roomExists(tfe.roomInfo.vnum)) then

      -- adding new room
      
      local x = 0; local y = 0; local z = 0;
      
      local foundAdjacent = false

      if (tfe.pendingExit ~= nil and not tfe.roomInfo.exits[tfe.pendingExit.direction]) then 
        display(tfe.roomInfo)
        tfe.roomInfo.exits[tfe.pendingExit.direction] = tfe.pendingExit.vnum
        tfe.pendingExit = nil
      end


      -- look for an adjacent room
      for exit, vnum in pairs(tfe.roomInfo.exits) do
        
        if (roomExists(vnum)) then
        
      		x,y,z = tfe.getRoomCoordinatesByExit(vnum, tfe.consts.reverse_dirs[exit])
      		-- echo('\nlocation is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
          foundAdjacent = true
          
          break;
        
        end
        
      end -- end looping over exits
      
      
      
      if (#getAreaRooms(areaId) &gt; 0 and not foundAdjacent) then
        cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; no adjacent room known or other rooms exist in this map!\n')
        cecho('You can use the "map connect &lt;direction you just went : [n|e|s|w|up|down|in|out]&gt; &lt;command you used to get here&gt;" to connect this room\n\n')
        return
      end

      -- echo('\nlocation is: (' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')

      addRoom(tfe.roomInfo.vnum)
		  setRoomArea(tfe.roomInfo.vnum, areaId);
  	  setRoomName(tfe.roomInfo.vnum, tfe.roomInfo.name)
  	  setRoomCoordinates(tfe.roomInfo.vnum, x, y, z)

    end
    
    -- updating exiting room if we haven't been into it before
    -- we can tell because it won't have a name yet...
    if (tfe.roomInfo.name ~= getRoomName(tfe.roomInfo.vnum)) then
  	  setRoomName(tfe.roomInfo.vnum, tfe.roomInfo.name)
      -- clear the temp room env color (grey)
      setRoomWeight(tfe.roomInfo.vnum, 1)
    end
    
    -- fix any area id's that have been mutilated by previous mappers
    if (getRoomArea(tfe.roomInfo.vnum) ~= areaId) then
      setRoomArea(tfe.roomInfo.vnum, areaId);
    end
    
    
    -- check terrain in this room
    local terrain = tfe.environment[tfe.roomInfo.terrain]
    if (terrain and getRoomEnv(tfe.roomInfo.vnum) ~= terrain) then
      setRoomEnv(tfe.roomInfo.vnum, terrain)
    end
    

		-- update room exit stubs (may change w/secret doors etc)
    local existingExits = getRoomExits(tfe.roomInfo.vnum)
		for exit, vnum in pairs(tfe.roomInfo.exits) do
			if(not existingExits[exit] and tfe.consts.short[exit]) then
      	setExitStub(tfe.roomInfo.vnum, tfe.consts.short[exit], true)
        
        -- add in a temp room for any rooms we haven't visited yet
        if (not roomExists(vnum)) then
          addRoom(vnum)
          setRoomArea(vnum, areaId);
          setRoomEnv(vnum, 272)
          -- set high room weight so we won't auto walk through it unless absolutely necessary
          setRoomWeight(vnum, 100)
          
          local x,y,z = tfe.getRoomCoordinatesByExit(tfe.roomInfo.vnum, exit)
          -- echo('\nnew location is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
          setRoomCoordinates(vnum, x, y, z)
        end
      
        -- cecho('\n&lt;green&gt;MAPPER: &lt;white&gt;joining ' .. tostring(tfe.roomInfo.vnum) ..' to room: ' .. tostring(vnum) .. ' - ' .. exit)
        setExit(tfe.roomInfo.vnum, vnum, tfe.consts.stubmap[exit])
        setExit(vnum, tfe.roomInfo.vnum, tfe.consts.stubmap[tfe.consts.reverse_dirs[exit]])
        
        
			end
    end -- end looping over exits

	 centerview(tfe.roomInfo.vnum)
     

 
   raiseEvent(tfe.events.ROOM_CHANGED, tfe.roomInfo)
 
  else
  
    cecho('\n&lt;red&gt;TFE MAP: &lt;white&gt; gmcp room info missing area id or room number\n')
    display(gmcp.Room.Info)
    
  end
  
  
end

tfe.getRoomCoordinatesByExit = function (vnum, dir)

  local x,y,z = getRoomCoordinates(vnum);
	local dx, dy, dz = unpack(tfe.consts.coordmap[tfe.consts.stubmap[dir]])
  x = x + dx
  y = y + dy
  z = z + dz
  return x, y, z
  
end

tfe.getAreaID = function(roomInfo)

  local area =  roomInfo.area .. ' : ' .. tostring(roomInfo.area_id)

	local areas = getAreaTable()
  
  if (areas[area]) then
    return areas[area]
  else
    cecho('\n&lt;green&gt;TFE MAP: &lt;white&gt;created new area: ' .. area .. '\n')
    -- display(roomInfo)
    return addAreaName(area)
  end

end

  tfe.deleteCurrentMapArea = function ()
  
  local areaId = tfe.getAreaID(tfe.roomInfo)
  deleteArea(areaId)
  echo('\nRESET CURRENT AREA\n')
  updateMap()

end</script>
			<eventHandlerList>
				<string>gmcp.Room.Info</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>last script (to trigger dependencies!)</name>
			<packageName></packageName>
			<script>raiseEvent('tfeMapperLoaded')</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>speedwalk locations</name>
			<packageName></packageName>
			<script>tfe.locations = tfe.locations or {}

local lookup = {
	hillies = 28018,
	pixies = 44904,
  denab = 28132,
  denabBank = 30389,
	kha = 27004,
	khaBank = 27042,
	med = 107,
	medBank = 144,
	pen = 37013,
	penBank = 37249,
	sos = 30752,
	voal = 20088,
	voalBank = 20027,
	cairn = 26568,
	knight = 21096,
	hollow = 91675,
	blade = 19370,
	wayward = 40585,
  whisper = 28134,
	chi = 25000,
	zaranders = 27500,
	barbs = 66071,
	denab = 28132,
	brith = 63534,
	tg = 17331,
	cycs = 44765,
	stonies = 19164,
	toys = 39008,
	vyans = 28146,
	root = 19376,
	yetis = 94611,
	ettercaps = 70104,
	cairnValley = 57258,
	temple = 21257,
	narak = 36070,
	halflings = 21076,
  midnight = 76594,
  corsair = 42511,
}

for name, vnum in pairs(lookup) do
  if (not tfe.locations[name]) then
    tfe.locations[name] = vnum
  end
end</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
