<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>repeat stuff jammed in prompt</name>
			<script>if (matches[3]) then
	local prompt = matches[2]
	local stuff = matches[3]
  echo('\n^^ PROMPT FAIL: [' .. stuff .. ']\n')
  feedTriggers(prompt .. '\n')
  feedTriggers(stuff .. '\n')
end
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(&lt;[^&gt;]*&gt;)(.+)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>parsing stuff</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse score (position and condition)</name>
				<script>player.position = matches[2]
player.condition = string.split(matches[3], ' ')

if (common.tableHasValue(player.condition, 'delirious')) then
	cecho('\n&lt;green&gt;SCORE: &lt;white&gt;tripping with the fishes\n')
	player.tripping = true
else
	player.tripping = false
end

common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
	raiseEvent(common.events.PARSED_SCORE)
end)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+Position:\s+\[\s+(\w+)\s+]\s+Condition: \[\s+(\w+)\s+\]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse group</name>
				<script>-- Leader: Darion
--
-- [ 14 Pal Dwf   ] Darion                209/209     94/94   138/138       122869
-- [ 41 Pal Dwf L ] Darion                641/641   100/100   205/205     11787449

-- pretend these players aren't in our group
-- need to do this if they don't have the teamwork triggers
-- i.e wont respond to commands / queries
local playerIgnore = {
	-- Marsuvious = true,
	-- Bashukin = true,
}

-- group row
if (matches[3]) then

	if (matches[2] == player.name or not player.tripping) then

		if playerIgnore[matches[2]] then
			echo(' &lt;-- ignored')
			return
		end

    local status = group[matches[2]] or {}

    status.hp = tonumber(matches[3])
    status.hp_max = tonumber(matches[4])
    status.mp = tonumber(matches[5])
    status.mp_max = tonumber(matches[6])
    status.moves = tonumber(matches[7])
    status.moves_max = tonumber(matches[8])
    status.xp = matches[9]

    -- 
    selectString(matches[1],1)
    replace(matches[1]:gsub(matches[9], common.commaCase(matches[9])))

    group[matches[2]] = status

		-- dupe into player info for conwenience
		if (matches[2] == player.name) then
			for key, val in pairs(status) do
				player[key] = val
			end
		end

		if (not player.tripping) then
			group.memberCount = group.memberCount + 1
			group.members = group.members or {}
			group.members[matches[2]] = true
		end

	else
		echo(' &lt;-- tripping')
	end

-- leader row
else

	if (matches[2] == player.name or not player.tripping) then
		group.leader = matches[2]
		if (not player.tripping) then
  		group.memberCount = 0
  		group.members = {}
		end
	else
		echo(' &lt;-- tripping')
	end

  common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
		-- echo('\n ^^ raising parsed group event\n\n')
		player.initPending = false
  	raiseEvent(common.events.PARSED_GROUP)
  end)

end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[\s+\d+\s+\w+\s+\w+\s+\w*\s*\]\s+(\S+)\s+(\d+)/(\d+)\s+(\d+)/(\d+)\s+(\d+)/(\d+)\s+(\d+)$</string>
					<string>^Leader:\s+(.*)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse prompt</name>
				<script>-- set prompt to this:

-- Prompt:
-- ?p' -- MORE -- '&lt;%f?f|@R%hhp@n @G%ee@n @B?m'[%mmv]'!m'%vmv'@n %gwm %xxp?l' %llhp' %d?b' %c'&gt;


-- need to have the group parsed aleady to have things to fill in
if ( not group.leader ) then

		echo('\nWaiting for leader before parsing prompt...\n')
		if (not player.initPending) then
			player.initPending = true
			common.initPlayer()
		end

else

	-- prompt flags:
	-- c - camouflaged
  -- h - hidden
  -- i - invisible
  -- P - player killing ok
  -- A - arena
  -- p - parry on
  -- S - sanctuary
  -- s - sneaking
  -- t - tracking
  -- x - searching
  -- B - burdened
  -- b - berserk skill active
  -- f - focus skill active
  -- M - you have new mudmail
	
	local promptFlags = matches[2]
	
	-- set parry state
	if string.find(promptFlags, 'p') then player.parry = true else player.parry = false end

	
	if string.find(promptFlags, '[chi]') then player.hidden = true else player.hidden = false end

  group[player.name].hp = tonumber(matches[3])
  group[player.name].mp = tonumber(matches[4])
  group[player.name].moves = tonumber(matches[5])

  player.hp = tonumber(matches[3])
  player.mp = tonumber(matches[4])
  player.moves = tonumber(matches[5])

  group.lowest_moves = tonumber(matches[6])

	if (matches[7] and matches[7] ~= '') then
		-- echo('\nsetting leader hp to ' .. tostring(matches[7]))
  	if (group[group.leader]) then
			group[group.leader].hp = tonumber(matches[7])
		else
			cecho('\n^^&lt;orange&gt;PROMPT &lt;white&gt; i spy leader hp but might not be grouped yet...\n')
		end

	end

	if (matches[9] == '-Dark-') then
		cecho('\n^^&lt;red&gt;\nIt\'s super dark yo! &lt;white&gt;-- make light\n')
	end

end

raiseEvent(common.events.PARSED_PROMPT)



-- examples...

-- &lt;209hp 94e 138mv 138wm 122617xp NESW&gt;
-- &lt;S|472hp 629e 150mv 150wm 12777631xp ??&gt;  &lt;-- sleeping prompt
-- &lt;304hp 28e [375mv] 152wm 1260782xp -Dark-&gt;

-- &lt;209hp 94e 138mv 138wm 122751xp NESW leaking guts&gt;
-- &lt;527hp 27e 181mv 161wm 7020514xp 500lhp EW&gt;
-- &lt;209hp 94e 138mv 138wm 122617xp NESW&gt;
-- &lt;527hp 27e 182mv 182wm 7020514xp ?? NESW&gt;
-- &lt;527hp 27e 181mv 161wm 7026324xp 500lhp EW covered in blood&gt;</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^&lt;(\w+\|)?(\d+)hp (\d+)e \[?(\d+)mv\]? (\d+)wm\s+\d+xp (\d+)?(lhp\s|\?\?\s)?([NESWneswUDud]+|-Dark-|none|\?\?)(\s.+)?&gt;\s*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse inventory</name>
				<script>
-- display(matches)

-- a stick of blue chalk           1  .10   a simple mug of water           1  .27
-- a fragment of burning red stone                                          1  .50

if (matches[2] == 'Coins') then

	-- start of inventory
	player.coins = tonumber(matches[3])
	player.coinWeight = tonumber(matches[4])
	player.parsingInventory = true
	player.inventory = {}


else

	if (matches[2] == 'Number') then
		-- this is the end of the inventory

		raiseEvent(common.events.PARSED_INVENTORY)
		player.parsingInventory = false


	else

		-- inventory line
		player.inventory[matches[2]] = tonumber(matches[3])

		if(matches[5]) then
			player.inventory[matches[5]] = tonumber(matches[6])
		end

	end

end


</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(Coins): (\d+) = \[ .* \] \s+ Weight: (\d+\.\d+) lbs</string>
					<string>^\s+(Number):\s+(\d+)\s+\( Max =\s+(\d+) \)</string>
					<string>^(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)\s+(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)</string>
					<string>^(an? .+?)\s+(\d+)\s+(\d*\.?\d+?)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse affects</name>
				<script>echo('^^ --- looking at affects...\n')
player.affects = {}

local affectWatcher = tempRegexTrigger([[^(Your? .+?)\s{3,}(\S.*)$]], function ()
	player.affects[matches[2]] = matches[3]
end)

common.onNextEvent(common.events.PARSED_PROMPT, function()

	killTrigger(affectWatcher)
	raiseEvent(common.events.PARSED_AFFECTS, player.affects)

end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Affect\s+Source\s*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse prepped</name>
				<script>player.prepped = {}

local prepTrig = tempRegexTrigger([[^\s*(\d+)\s*(.+?)\s*\d+\s*$]], function ()
	player.prepped[matches[3]] = tonumber(matches[2])
end)

common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
	killTrigger(prepTrig)
	raiseEvent(common.events.PARSED_PREPARED, player.prepped)
end)	</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You have no spells prepared.</string>
					<string>^Num\s+Spell\s+Mana\s*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>room info 1</name>
				<script>-- showMultimatches()
roomInfo = {}

roomInfo.roomName  = multimatches[1][2]
roomInfo.exits = string.split(rex.gsub(multimatches[2][2], [[\s*#\d+]], ''),  " ")

if map.moveToProcess == 1 then
	map.moveToProcess = 2
end

send('queue typo &amp; scan')

raiseEvent(common.events.PARSED_ROOM_INFO, roomInfo)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^([^[].*)$</string>
					<string>^\[Exits: (.*)]$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="yes" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>room info 2/3</name>
				<script>roomInfo = {}

-- showMultimatches()
-- display(multimatches)
roomInfo.roomName = multimatches[1][2]

roomInfo.lighting = multimatches[3][2]
roomInfo.time = multimatches[3][3]
roomInfo.terrain = multimatches[3][4]


roomInfo.exits = {}
multimatches[4][2]:gsub(".", function(exit)
    table.insert(roomInfo.exits, map.consts.exitmap[exit])
end)


roomInfo.moon = multimatches[4][3]
roomInfo.roomSize = multimatches[4][4]

roomInfo.weather = string.split(multimatches[5][2], '; ')

if map.moveToProcess == 1 then
	map.moveToProcess = 2
end

send('queue typo &amp; scan')

raiseEvent(common.events.PARSED_ROOM_INFO, roomInfo)

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>5</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(.+?)\s+$</string>
					<string>^\+=-+=\+$</string>
					<string>^\|\s+Lighting:\s+(.+?)\s+Time:\s+(.+?)\s+Terrain:\s+(.+?)\s+\|$</string>
					<string>^\|\s+Exits:\s+(.+?)\s+Moon:\s+(.+?)\s+Room Size:\s+(.+?)\s+\|$</string>
					<string>^\|\s+Weather:\s+(.+?)\s+\|$</string>
					<string>^\+=-+=\+$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>parse equipment</name>
				<script>player = player or {}
player.gear = player.gear or {}
player.itemSlot = player.itemSlot or {}

if (matches[2] == 'Equipment') then
	-- start of parsing
	
	player.gear.parsing = true
	player.gear = {}
	-- cecho(' &lt;--- parsing start')
	
elseif (matches[2] == 'Weight') then
	
	-- end of parsing
	player.gear.parsing = nil
	player.gear.currentSlot = nil
	
	raiseEvent(common.events.PARSED_EQUIPMENT)
	-- cecho(' &lt; --- parsing end')
	-- display(player.gear)

else
 
 	-- if this line has a slot, get rid of the redundant part and set it to be the current slot
	if (matches[2] ~= '') then
		player.gear.currentSlot = rex.gsub(matches[2], [[^(floating|worn on|worn around|worn about) ]], "", 1)
	end
	
	local item = common.itemSanitize(matches[4])
	
	player.gear[player.gear.currentSlot] = player.gear[player.gear.currentSlot] or {}
	player.gear[player.gear.currentSlot][matches[3]] = {item = item, condition = matches[5] }
	
	player.itemSlot[item] = {slot=player.gear.currentSlot, layer=matches[3]}
	-- cecho(' &lt;--- its some gear ')

end



           </script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+ \+\+\+ (Equipment) \+\+\+</string>
					<string>^(Weight):</string>
					<string>^(.*?)\s+(bottom|under|base|over|top)\s+(.*?)\s+(worthless|damaged|very worn|worn|very scratch|scratched|reasonable|good|very good|excellent|perfect)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>player status</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>not tripping anymore</name>
				<script>player.tripping = false</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The world returns to normal color.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>tripping</name>
				<script>player.tripping = true</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You see colors.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>standing status</name>
				<script>player.position = 'standing'</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You wake and stand up.</string>
					<string>^You stand up.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>sleep status</name>
				<script>player.position = 'sleeping'</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You lie down and go to sleep</string>
					<string>^You go to sleep .*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>resting status</name>
				<script>player.position =  'resting'</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You wake and sit up.</string>
					<string>^You sit down.*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Parry set to x.</name>
				<script>if (matches[2] == 'true') then
	player.parry = true
else
	player.parry = false
end

player.parryQueue = (player.parryQueue or 1) - 1
cecho('&lt;yellow&gt; &lt;-- parry queue -- (' .. player.parryQueue .. ')')

if player.parryQueue &lt; 0 then
  player.parryQueue = 0
  cecho('\n&lt;red&gt;PARRY: &lt;white&gt;attempted to reduce queue below zero\n')
end

if (player.pendingParryChange ~= true) then
  
	player.pendingParryChange = true
  
  common.onNextEvent(common.events.PARSED_PROMPT, function (evt, args)
  	raiseEvent(common.events.PARRY_STATE_CHANGE)
  	player.pendingParryChange = false
  end)
	
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Parry set to (true|false)\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>mapping</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>The x to the y is closed.</name>
				<script>disableTrigger('The x to the y is closed.')

local vic = common.dotCase(common.toMurderString(matches[2]))

-- convert north gate etc -&gt; gate
vic = rex.gsub(vic, '(north|east|south|west|down|up|above|below).', '') 

local dir = matches[3]

send('move beam &amp; pull lever &amp; turn crank &amp; pull cord')
send('unlock ' .. vic .. ' &amp; unlock ' .. dir)
send('open ' .. vic .. ' &amp; open ' .. dir)
send('knock ' .. vic .. ' &amp; knock ' .. dir)
send('pound ' .. vic .. ' &amp; pound ' .. dir)

tempTimer(2, function () send('scan') end, 'scan after attempting to open')

tempTimer(1, function ()
	enableTrigger('The x to the y is closed.')
end, 'reenable closed door trig')

if (mapper.speedwalking) then
	send(dir)
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^The (.+) to the (.+) (is|are) closed.</string>
					<string>^Perhaps you should open the (double) (doors)</string>
					<string>^The (.*) (below|above) you (is|are) closed.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>no exit to the x</name>
				<script>
local exitDir = matches[2]

cecho('\n&lt;green&gt;MOVE: &lt;white&gt;failed to go ' .. exitDir .. '... ' .. common.roomId .. '\n' )

local exits = {
  east = {
  	[1022]  = 'move bush &amp; east',
		[28102] = 'move moss &amp; east',
		[28095] = 'move bush &amp; east',
		[48175] = 'move landslide &amp; east',
		[66014] = 'dig ice',
		[75000] = 'move rock',
		[21135] = 'enter crack &amp; get chain &amp; queue loop chain &amp; queue drop chain',
		[65503] = 'enter crev',
		[91662] = 'open crack',
		[37161] = 'move board &amp; enter hole',
		[23502] = 'enter break',
    [82021] = 'stand &amp; break ice',
    [82012] = 'enter crev',
    [82002] = 'dig drift &amp; scan',
    [4008] = 'enter water',
    [48152] = 'move pile',
	},
	west = {
		[28134] = 'move moss &amp; west',
		[28102] = 'move bush &amp; west',
		[37045] = 'move landslide &amp; west',
		[48180] = 'touch lotus',
		[47761] = 'move bush',
		[32023] = 'pull lever &amp; west',
		[66058] = 'dig ice',
		[35963] = 'move rock',
		[26542] = 'enter crev',
		[65502] = 'enter crack',
		[37055] = 'move board &amp; enter hole',
		[37160] = 'twist knob',
		[48169] = 'lift beam &amp; pull lever',
		[23506] = 'enter break',
    [82024] = 'stand &amp; break ice',
    [82013] = 'enter crev',
    [82003] = 'dig drift &amp; queue scan',
    [48153] = 'move pile',
	},
	north = {
		[44908] = 'enter water',
		[44885] = 'move bush &amp; north',
		[44904] = 'jump north',
		[27040] = 'jump north',
		[27274] = 'move boulder &amp; scan',
		[34500] = 'pull torch &amp; north',
		[25004] = 'enter crev',
		[2505]  = 'twist torch &amp; north',
		[37037] = 'move branch &amp; enter veget',
		[91679] = 'enter veget',
		[74005] = 'move tree &amp; north',
		[30000] = 'dig mound',
		[66011] = 'spread ashes',
		[66063] = 'move tapes',
		[53000] = 'yell khiren',
		[44765] = 'pull slab',
		[30877] = 'enter crevice',
		[51064] = 'move drift',
		[39348] = 'move bush',
		[75013] = 'jump north',
		[23091] = 'cross stream',
		[65504] = 'enter crack',
		[47000] = 'move bush',
    [82035] = 'stand &amp; break ice',
    [34518] = 'dig drift &amp; scan',
    [94604] = 'touch stone',
    [27255] = 'push circ &amp; push squar &amp; push diam &amp; push triang',
    [2037] = 'enter hole',
    [48152] = 'open beam',
    [48165] = 'open slab',
    [566] = 'pull lever',
	},
	south = {
		[44909] = 'enter water',
		[44886] = 'move bush &amp; south',
		[44905] = 'jump south',
		[34501] = 'push stone &amp; south',
		[25012] = 'enter crev',
		[2517]  = 'push wall &amp; south',
		[91683] = 'enter veget',
		[91682] = 'move branch &amp; enter veget',
		[74004] = 'move tree &amp; south',
		[74061] = 'cut veg',
		[47777] = 'dig drift',
		[47767] = 'climb down',
		[47773] = 'climb down',
		[47772] = 'climb down',
		[47771] = 'climb down',
		[47770] = 'climb down',
		[47769] = 'climb down',
		[47777] = 'dig drift',
		[47761] = 'move plant',
		[19132] = 'dig mound',
		[34579] = 'ask dwa demon',
		[73500] = 'push stone',
		[37045] = 'move bush',
		[75014] = 'climb south',
		[37546] = 'move moss',
		[51753] = 'cross stream',
		[65505] = 'enter crack',
		[40534] = 'move bush',
    [82036] = 'stand &amp; break ice',
    [82000] = 'dig drift &amp; scan',
    [5110] = 'touch stone',
    [2039] = 'climb up',
    [2040] = 'climb up',
    [48150] = 'move beam',
    [48149] = 'get pebble',
    [48168] = 'open slab',
    [481] = 'push rock',

	},
	below = {
		[48205] = 'move slab',
		[40251] = 'enter hole',
		[73502] = 'move stone',
		[68051] = 'pull lever',
		[68043] = 'push statue',
		[21326] = 'call essyn',
		[49783] = 'search',
		[39510] = 'pull chain',
		[94274] = 'move log',
		[94264] = 'move brush',
		[20086] = 'move floor',
		[91668] = 'climb bould',
		[31000] = 'climb stone',
    [3813] = 'move needles &amp; trace pent',
    [95768] = 'search plant &amp; enter opening',
    [95750] = 'enter log',
    [30402] = 'move granite',
   
	},
	above = {
		[73606] = 'move stone',
		[68029] = 'throw dart &amp; pull lever',
		[68039] = 'pull lever',
		[68027] = 'call dact &amp; place globe',
		[21325] = 'ask essyn festival',
		[49785] = 'search',
		[94251] = 'move brush',
		[94268] = 'move log',
		[71625] = 'move rock',
		[91667] = 'climb bould',
    [95785] = 'enter fissure',
    [95769] = 'search plant &amp; enter opening',
	},
	that = {
		[33357] = 'move crates',
	}
}


if exits[exitDir] then

	local thisExit = exits[exitDir]

  if (thisExit[common.roomId]) then
  	send(thisExit[common.roomId])
	else

  	local exit = exitDir
  	if (exit == 'below') then exit = 'down' end
  	if (exit == 'above') then exit = 'up' end

  	send('open ' .. exit .. ' &amp; scan')

  end

end


</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You see no exit to the (.*)\.</string>
					<string>^You see no exit (.*) you\.</string>
					<string>^There is no exit in (that) direction\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>climb up fail</name>
				<script>send('climb up')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You grab the thick tree bark and begin upwards, but come sliding back down.</string>
					<string>You slip on some slime and fall back into the water.</string>
					<string>You will have to climb your way out of here it looks like.</string>
					<string>Unable to get a good handhold, you slip and fall.</string>
					<string>You grab ahold of the face of the cliff, but lose your grip.</string>
					<string>You can't fly!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>up failed</name>
				<script>send('up')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You struggle up the steep slope, only to come sliding back down.</string>
					<string>You try to tackle the large hill, but come sliding back down its grassy side.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>special doors/exits</name>
				<script>
local exitDir = matches[2]

cecho('\n&lt;green&gt;MOVE: &lt;white&gt;failed to exit... ' .. common.roomId .. '\n' )

local exits = {
	[27500] = 'knock three',
	[2522]  = 'jump pit',
}


if exits[common.roomId] then

  send(exits[common.roomId])

end


</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>The oak door to the east is closed.</string>
					<string>I dunno, it looks kinda like a long drop...</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You can't do that while mounted.</name>
				<script>common.onNextEvent(common.events.ROOM_CHANGED, function ()
	send('mount')
end)
send('dismount')
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't do that while mounted.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>need to climb up</name>
				<script>send('climb up')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You see no exit above you.</string>
					<string>There's no way to reach the top of the cliff unless you have the ability to climb it.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>need to climb down</name>
				<script>send('climb down')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You see no exit below you.</string>
					<string>You step toward the edge of the cliff and decide not to walk off the edge.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>blind</name>
				<script>send('typo')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>You can't see a thing!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>disbelieve illusion</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>A face emerges from the living wall of sand</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>special exits</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>woodworms</name>
					<script>send('enter gap')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The gap is too small for you to just walk in.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>raven wood - dive</name>
					<script>send('dive water')</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You will have to dive into the water.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>tfe-mapper</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Movement Failed</name>
				<script>-- RoomCount = RoomCount +1
-- RoomT[RoomCount] = {}
-- RoomT[RoomCount]["sd"] = "fail"

map.move_queued = false
echo(' &lt;--- cleaing move queue (went bad direction)')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You can't go that way!$</string>
					<string>^You see no exit</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Movement</name>
				<script>local badWords = {
	lie = true,
	sit = true,
	stand = true,
	wake = true,
	jump = true,
}


if (not badWords[matches[2]]) then

  if (map.move_queued) then
  	echo(' &lt;--- unsetting move queued')
  	map.move_queued = false
  end

	-- replace data from keypress with the parsed data
	if (map.lastMoveKey ~= '') then
		map.lastMoveKey = ''
		map.moveToProcess = 0
	end
	
  map.lastMoveDirection = matches[3];

  -- we detected a move, but hadn't finished processing the previous move
  if map.moveToProcess ~= 0 then

  	map.lost = true
  	map.moveToProcess = 0
  	-- try and find us on the map... we are lost!
  	if (not mapper.speedwalking) then
  		echo('\n\n WE ARE LOST!!!! - stopping mapping (moved before processed the previous move)\n\n')
  		send('look')
  	end

  else

  	map.moveToProcess = 1;

  end

  -- echo(' &lt;-- sending move event: ' .. matches[3] .. '\n')
  raiseEvent(common.events.MOVE_DETECTED, matches[3])

  -- skipStep()
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You (\w+) (east|west|north|south|up|down)( through the dark webbing)?\.$</string>
					<string>^You follow (\w+) (east|west|north|south|up|down)\.$</string>
					<string>^You ride (\S+) (east|west|north|south|up|down)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>move - completed (room number found)</name>
				<script>-- echo("arex " .. matches[3] .. "\n")
-- echo("room id " .. matches[2])

map.areaIdTFE = matches[3]
map.areaId = getAreaIdByTfeId(map.areaIdTFE);

local newRoomId = tonumber(matches[2])

-- if we moved due to a keypress without a leave message being triggered
-- aka a fake move (fancy room exit/enter message)
if (map.lastMoveKey ~= '') then
	local dir = map.consts.exitmap[map.lastMoveKey]
	map.lastMoveKey = ''
	map.lastMoveDirection = dir;
	raiseEvent(common.events.MOVE_DETECTED, dir)
end

-- if this is different to the room we were just in, trigger a room change event
if (newRoomId ~= common.roomId) then

	common.previousRoomId = common.roomId
	common.roomId = newRoomId

  -- we detected a move, but didn't get a desc/title
  if map.moveToProcess == 1 then
  	-- try and find us on the map... we are lost!
  	map.lost = true
  	map.moveToProcess = 0

  	if (map.mapping) then
    	echo('\n\n MAP - pausing mapping (move without getting title/exits)\n\n')
    	send('look')
  	end

  end

  -- we have detected a movement and got a room title+exists since then
  if not map.lost and map.moveToProcess == 2 then

    if (map.mapping) then
			if (not roomExists(common.previousRoomId)) then
    		cecho('\n\n &lt;red&gt;MAPPER: &lt;white&gt;pausing mapping (previous room wasn\'t mapped)\n\n')
				map.lost = true
				map.moveToProcess = 0
			else
				addCurrentRoom()
			end
  	else
  		centerview(newRoomId);
    end

  	map.moveToProcess = 0

  else

  	-- if moveToProcess == 0
  	-- we didn't pick up a movement
  	-- probably because we didn't move...

  	-- if we're in an unexpected roomId then update our position
  	-- if we know about this room


		-- if this is a known room it will have a name
    if(roomExists(newRoomId)) then

			if (map.mapping) then
				echo('\n\nMAP: we are found again! (resuming)\n\n')
    	end

			map.lost = false
			map.moveToProcess = 0
			centerview(newRoomId);

  	end


  end

	raiseEvent(common.events.ROOM_CHANGED, newRoomId)

end

</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Room #((\d?\d?)\d\d\d)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>hide typo message spam</name>
				<script>deleteLine()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^What typo do you wish to report\?$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>You are too exhausted.</name>
				<script>if (mapper.speedWalking) then

	tempTimer(3, function () send('sleep') end)
	mapper.pause()

  tempTimer(40, function ()
		mapper.resume()
  	send('stand')
  	mapper.nextStep()
  end)

end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You are too exhausted.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>move queued</name>
				<script>map.move_queued = true
echo('\n^^ &lt;--- setting move queued')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[ Queued.*: (north|east|south|west|up|down) \]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>clear queued move</name>
				<script>map.move_queued = false
echo('\n^^ &lt;--- clear move queue (combat)')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You can't walk away from a battle - use flee.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>teamwork</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>meet at x</name>
				<script>local rnum = matches[3]
send('look')

tempTimer(2, function ()
  expandAlias('findMe')

  mapper.gotoRoom(rnum, function ()
  	tempTimer(1, function ()
  		send('gt ' .. player.name .. ' is now at ' .. tostring(common.roomId))
  	end)
  end)
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "meet at (\d+)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>go to x</name>
				<script>local pname = matches[3]
local rnum = matches[4]

if (pname == player.name) then
	send('gt omw')
  send('look')

  tempTimer(2, function ()
    expandAlias('findMe')

    mapper.gotoRoom(rnum, function ()
    	tempTimer(1, function ()
    		send('gt ' .. player.name .. ' is now at ' .. tostring(common.roomId))
    	end)
    end)
  end)
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "(\w+) go to (\d+)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>time for x</name>
				<script>expandAlias(matches[4])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "time (for|to) (.*)"</string>
					<string>^(You) tell your group[^:]*: "time (for|to) (.*)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>x time for y</name>
				<script>
if (matches[3] == player.name) then
	expandAlias(matches[4])
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(An? .+?|The .+?|\w+) tells the group[^:]*: "(\w+) can you (.*)"</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>someone joins a group</name>
				<script>group = {}

send('group')</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^You join (.*)'s group.</string>
					<string>^(.*) joins (.*)'?s? group.</string>
					<string>^You remove (.*) from your group.</string>
					<string>^You leave (.*)'s group.</string>
					<string>^(.*) stops following you.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>speed walks</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>go</name>
				<script>local dest = matches[2]

local lookup = {
	hillies = 28018,
	pixies = 44904,
  denab = 28132,
  denabBank = 30389,
	kha = 27004,
	khaBank = 27042,
	med = 107,
	medBank = 144,
	pen = 37013,
	penBank = 37249,
	sos = 30752,
	voal = 20088,
	voalBank = 20027,
	cairn = 26568,
	knight = 21096,
	hollow = 91675,
	blade = 19370,
	wayward = 40585,
  whisper = 28134,
	chi = 25000,
	zaranders = 27500,
	barbs = 66071,
	denab = 28132,
	brith = 63534,
	tg = 17331,
	cycs = 44765,
	stonies = 19164,
	toys = 39008,
	vyans = 28146,
	root = 19376,
	yetis = 94611,
	ettercaps = 70104,
	cairnValley = 57258,
	temple = 21257,
	narak = 36070,
	halflings = 21076,
	mirrors = 51500,
	ironwood = 499,
  mojBase = 3813,
  mojBank = 3814,
  soup = 170,
  bots = 94604,
}

local rnum = lookup[dest] or dest

if (not roomExists(rnum) and murder.xpoints) then
	-- rnum = murder.xpoints[dest].roomId
	local xpoint = murder.xpoints[tonumber(dest)]
	
	if (xpoint) then rnum = xpoint.roomId end
	
end


if (roomExists(rnum)) then

	cecho('&lt;green&gt;GO: &lt;white&gt;rnum #' .. tostring(rnum) .. '\n')
  local endCmd = matches[3]


	mapper.gotoRoom(rnum, function () 
		if (endCmd) then
			expandAlias(endCmd)
		end
	end)
	
else
	echo('\nInvalid speed walk location\n')
	mapper.stop()
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^go (\S+)\s?&amp;?\s?(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>stop movement</name>
				<script>mapper.stop()</script>
				<command></command>
				<packageName></packageName>
				<regex>^stop$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>resume movement</name>
				<script>mapper.resume()</script>
				<command></command>
				<packageName></packageName>
				<regex>^resume$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>pause movement</name>
				<script>mapper.pause()</script>
				<command></command>
				<packageName></packageName>
				<regex>^pause$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>tfe-mapper</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>set area name</name>
				<script>setAreaName(map.areaId, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^setAreaName (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>reset current area</name>
				<script>deleteArea(map.areaId)
map.areaId = nil
common.previousRoomId = nil
map.lastMoveDirection = nil
echo('\nDELETED CURRENT MAP\n')
updateMap()</script>
				<command></command>
				<packageName></packageName>
				<regex>^resetCurrentArea$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>find me</name>
				<script>findMe()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(findMe|find me)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>mapper start</name>
				<script>send('look')
tempTimer(2, function()
	echo('\n\nMAPPER: staring!\n\n')
  map.mapping = true
  map.lost = false
	common.previousRoomId = nil
	addCurrentRoom()
end)

</script>
				<command></command>
				<packageName></packageName>
				<regex>^(mapperStart|mapper start|m start)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>mapper stop</name>
				<script>map.mapping = false</script>
				<command></command>
				<packageName></packageName>
				<regex>^(mapperStop|mapper stop|m stop)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>mapper moved x</name>
				<script>local dir = matches[3]

if (map.consts.exitmap[dir]) then
	dir = map.consts.exitmap[dir]
end

if (not map.consts.short[dir]) then

	cecho('&lt;red&gt;MAPPER: &lt;white&gt; invalid direction! - ' .. tostring(dir) .. '\n')

else

	map.lastMoveDirection = dir
  map.move_queued = false
	map.lost = false
	map.moveToProcess = 0

	addCurrentRoom()

end

</script>
				<command></command>
				<packageName></packageName>
				<regex>^(m m|mapper moved) (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>fake move</name>
				<script>fakeMove(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^fakeMove (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>^fm([neswud])</name>
				<script>local dir = map.consts.exitmap[matches[2]]

fakeMove(dir)
send(dir)</script>
				<command></command>
				<packageName></packageName>
				<regex>^fm([neswud])</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>movemen( by n e s w u d keys)</name>
				<script>-- deleteLine()
map.lastMoveKey = matches[2]
send(matches[1], false)
map.moveToProcess = 1;
-- echo('setting last move key to ' .. matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^([neswud])\b\s?(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>setup.prompt</name>
				<script>send("prompt ?p' -- MORE -- '&lt;%f?f|@R%hhp@n @G%ee@n @B?m'[%mmv]'!m'%vmv'@n %gwm %xxp?l' %llhp' %d?b' %c'&gt;")
</script>
				<command></command>
				<packageName></packageName>
				<regex>setup.prompt</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Misc</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>show triggers</name>
				<script>displayTempTriggers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^triggers$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>show timers</name>
				<script>displayTempTimers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^timers$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>show event handlers</name>
				<script>displayEventHandlers()</script>
				<command></command>
				<packageName></packageName>
				<regex>^events$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>killAll</name>
				<script>display(tempTimers)
display(tempTriggers)

for id, val in pairs(tempTimers) do
	killTimer(id)
end

for id, val in pairs(tempTriggers) do
	killTrigger(id)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^killAll$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>initial player status / config</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

common = common or {}

player = player or {}


common.initPlayer = function ()

	echo('\n\nINITIAL STATUS CHECK\n\n')
	
	loadSavedGearSets()

	-- GET PLAYER NAME
  timedTempTrigger(5, 1, [[^\s*([A-Z][a-z]+)\s*$]], function ()
		-- echo('\ncharacter is: [' .. matches[2] .. ']\n')
		player.name = matches[2]

		if (player.scripts and player.scripts[player.name]) then
			echo('\nRunning player script for ' .. player.name .. '!\n')
			player.scripts[player.name]()
		end


		-- if (not common.topContainer) then
  		
			-- init windows
      common.topContainer = Geyser.Container:new({
        name = "top_container",    -- give it a unique name here
  			x=0,
  			y=0,                   
        width = "100%", 
				color = "green",
  			height="25%",
      })
			
			common.mapContainer = Geyser.Container:new({
        name = "map_container",    -- give it a unique name here
  			x=0,
  			y=0,                   
        width = "40%", 
  			height="100%",
      }, common.topContainer)
			
			common.chatContainer = Geyser.Container:new({
        name = "chat_container",    -- give it a unique name here
  			x="40%",
  			y=0,                   
        width = "60%", 
  			height="100%",
      }, common.topContainer)
  		
  				-- init windows
      common.mapper = Geyser.Mapper:new({
        name = "geyser_map",    -- give it a unique name here
  			x="2%",
  			y="2%",                   
        width = "96%", 
  			height="96%",
      }, common.mapContainer)
  		
      common.chatConsole = Geyser.MiniConsole:new({
        name = "geyser_chat",    -- give it a unique name here
  			x="2%",
  			y="2%",                   
        width = "96%", 
  			height="96%",
  			autoWrap = true,
        color = "black",
        scrollBar = true,
        fontSize = 14,
      }, common.chatContainer)
  		
		-- end


	end)

	send('score &amp; eq &amp; group &amp; inv &amp; typo &amp; prep')

end</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>tfe-mapper</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>mapper variables / consts etc</name>
				<packageName></packageName>
				<script>mudlet = mudlet or {};
mudlet.mapper_script = true
map = map or {};

map.consts = map.consts or {}

map.move_queued = false

map.mapping = false

map.moveToProcess = 0

map.lost = false

map.lastMoveKey = ''

map.consts.exitmap = {
    n = 'north',    e = 'east',
    w = 'west',     s = 'south',
    u = 'up',       d = 'down',
	  N = 'north',    E = 'east',
    W = 'west',     S = 'south',
    U = 'up',       D = 'down',
}


map.consts.short = {}
for k,v in pairs(map.consts.exitmap) do
    map.consts.short[v] = k
end

-- for some reason the speed walker doesn't use shorts for up/down
map.consts.exitmap['up'] = 'up'
map.consts.exitmap['down'] = 'down'

map.consts.stubmap = {
    north = 1,      east = 4,
    west = 5,       south = 6,
    up = 9,         down = 10,          ["in"] = 11,        out = 12,
    [1] = "north",  [4] = "east",
    [5] = "west",   [6] = "south",
    [9] = "up",     [10] = "down",
}

map.consts.coordmap = {
    [1] = {0,1,0},      [4] = {1,0,0},
    [5] = {-1,0,0},     [6] = {0,-1,0},
    [9] = {0,0,1},      [10] = {0,0,-1},
}

map.consts.reverse_dirs = {
    north = "south", south = "north",
		west = "east", east = "west",
		up = "down", down = "up",
}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>speedwalking code</name>
				<packageName></packageName>
				<script>
mapper = mapper or {
	enabled=false,
	speedwalking = false,
	paused = false,
	exits={},
	waypoints = {},
	currentWaypoint = 0,
	events = {
		PATH_COMPLETE = 'MURDER:path_completed'
	},
	move_pending = nil,
	idleCheckTimer = nil,
	roomChangeHandler = nil,

}



function doSpeedWalk()

	map.mapping = false

	mapper.speedwalk()

  -- echo("Path we need to take: " .. table.concat(speedWalkDir, ", ") .. "\n")
  -- echo("Rooms we'll pass through: " .. table.concat(speedWalkPath, ", ") .. "\n")
end


function fakeMove (direction)
	cecho('\n&lt;green&gt;MAPPER: &lt;white&gt;faking move...\n')
	feedTriggers('You lumber ' .. direction .. '.\n')
end


function findMe ()
	map.moveToProcess = 0
	centerview(common.roomId);
end



function mapper.speedwalk (callback)

	-- make sure the destination is reachable
	if (speedWalkPath and #speedWalkPath) then

		-- send('opt brief')
 		mapper.gotoRoom(speedWalkPath[#speedWalkPath], function ()

			send('queue look')
			if (callback) then
				callback()
			end

		end)

	else

		cecho('\n&lt;red&gt;MURDER: &lt;white&gt;unable to reach requested room or already in it?\n')

	end

end


function mapper.gotoRoom (roomNum, callback)

	-- make sure the destination is reachable
	if (roomNum and roomExists(common.roomId)) then

  	mapper.speedwalking = true

		mapper.setWaypoints({roomNum})

		mapper.callback = callback

		mapper.start()

	else

		cecho('\n&lt;red&gt;MURDER: &lt;white&gt;error, no path available to requested room \n')

	end

end

function mapper.setWaypoints (waypoints)
	mapper.waypoints = waypoints
	mapper.clearPendingMove()
	mapper.currentWaypointIdx = 0

end

function mapper.clearPendingMove ()
	if (mapper.move_pending) then
		-- cecho('\n&lt;green&gt;MURDER: &lt;white&gt;Pending move cleared!')
		mapper.move_pending()
		mapper.move_pending = nil
	end
end



function mapper.start ()

	map.pre_walk_mapping = map.mapping

	map.mapping = false

	map.move_queued = false
  mapper.clearPendingMove()

  mapper.enabled = true
	mapper.paused = false

	send('typo &amp; group')

	-- cecho('\n\nwaiting for : ' .. common.events.PARSED_GROUP .. '\n')

	common.onNextEvent(common.events.PARSED_GROUP, function ()

  	mapper.currentWaypointIdx = 0

		mapper.advanceWaypoint()

	end)

end

function mapper.stop ()
	cecho('\n\n&lt;red&gt;MAPPER: &lt;white&gt;muder path stopped\n\n')
	mapper.enabled = false

	mapper.speedwalking = false
	mapper.exploring = false

	map.mapping = map.pre_walk_mapping

	mapper.callback = nil

	mapper.clearPendingMove()

end



function mapper.advanceWaypoint ()

	mapper.currentWaypointIdx = mapper.currentWaypointIdx + 1

	if (not mapper.waypoints[mapper.currentWaypointIdx]) then

		-- kill any outstanding timers:
		mapper.clearShortSpeedWalkTimer()

		-- cecho('\n\n&lt;green&gt;MURDER: &lt;yellow&gt;MURDER PATH COMPLETE\n\n')

		local cb = mapper.callback

		mapper.stop()

		if (cb) then
			cb()
		end

		raiseEvent(mapper.events.PATH_COMPLETE)

	else

		-- find the next waypoint...
  	mapper.currentWaypoint = tonumber(mapper.waypoints[mapper.currentWaypointIdx])
  	mapper.updatePath()

		-- cecho('\n&lt;blue&gt;MURDER: next invoked (from advancing waypoint)!\n')
		mapper.nextStep()

	end

end

function mapper.updatePath ()
	cecho('&lt;green&gt;pathing: &lt;white&gt;' .. tostring(common.roomId) .. ' to ' .. tostring(mapper.currentWaypoint))
	if (roomExists(common.roomId)) then
  	getPath(common.roomId, mapper.currentWaypoint)
  	mapper.speedWalkDir = speedWalkDir
    mapper.speedWalkPath = speedWalkPath
  	mapper.speedWalkPath[0] = common.roomId
  	mapper.walkPosition = 1
	else
		cecho('\n&lt;red&gt;MURDER: &lt;white&gt;unable to update path., current room not in map\n')
	end
end




local shortSpeedWalkTimerId

function mapper.startShortSpeedWalkTimer ()

	-- clear any existing timer
	mapper.clearShortSpeedWalkTimer()

	if (mapper.enabled) then
  	-- give us 5 seconds to move...
  	shortSpeedWalkTimerId = tempTimer(5, function ()
			shortSpeedWalkTimerId = nil
  		cecho('\n&lt;yellow:yellow&gt;MURDER: &lt;white:black&gt;5 seconds without move!!! - updating path...\n')
  		mapper.reroute()
  	end, 'short speed walk timer')
	end

end

function mapper.clearShortSpeedWalkTimer ()
	if (shortSpeedWalkTimerId) then
		killTimer(shortSpeedWalkTimerId)
	end
	shortSpeedWalkTimerId = nil
end



function mapper.move (cmd)

		-- send move command
	if (not mapper.move_pending) then

		local lastMoveDir = map.consts.exitmap[mapper.speedWalkDir[mapper.walkPosition]]

		mapper.startShortSpeedWalkTimer()

		mapper.move_pending = common.onNextEvent(common.events.ROOM_CHANGED, function (evt)

			mapper.clearShortSpeedWalkTimer()
			mapper.clearPendingMove()

			mapper.walkPosition = mapper.walkPosition + 1


			if (common.roomId == tonumber(mapper.speedWalkPath[mapper.walkPosition - 1])) then
				mapper.nextStep()
			else
				cecho('\n\n&lt;red&gt;MURDER: &lt;white&gt;unexpected room - rerouting\n\n')
				display(mapper.speedWalkPath[mapper.walkPosition - 1])
				display(common.roomId)
				mapper.reroute()
			end

		end)

		send(cmd)

	else -- else mapper.move_pending already exists

		cecho('\n&lt;red&gt;MURDER: &lt;white&gt;attempted to move while move was already pending (prob impatient timer)\n')

	end

end

function mapper.reroute ()
	mapper.updatePath()
	mapper.clearPendingMove()
	-- cecho('\n&lt;blue&gt;MURDER: &lt;white&gt;next invoked (reroute)!\n')
	mapper.nextStep()
end


function mapper.resume ()
	mapper.paused = false
	-- send('gt murdering will resume')
	if (mapper.speedwalking) then
		-- update the route in case there were shenanigans
		mapper.reroute()
	else
		send('scan')
	end
end

function mapper.pause ()
	mapper.paused = true
	-- send('gt murdering will be suspendend after current tasks')
end


function mapper.nextStep()


	if (mapper.enabled and not mapper.paused) then

		-- if we're at the end of this waypoin then advance...
  	if (mapper.walkPosition &gt; #mapper.speedWalkDir) then
			-- cecho('\n&lt;orange&gt;MURDER: &lt;white&gt;No commands left for this waypoint!\n')
			-- echo('\n\nTIME to go to the next waypoint\n\n')
			mapper.advanceWaypoint()
			return
		end

		-- pause to get moves if someone is low on moves
		if (group.lowest_moves &lt;= 30) then
			send('gt someone be low on moves, waiting for 30...')
			mapper.paused = true

			send('gt time to rest')
			tempTimer(25, function()
				send('gt time to stand')
			end)

			tempTimer(30, function()
				mapper.paused = false
				mapper.nextStep()
			end)

			return -- low on moves. no moves to be done this time...

		end -- not low on moves



		-- /****** WE ARE MOVING IF WE GOT HERE ********/ --


		-- get the next move direction
		local dir = map.consts.exitmap[ mapper.speedWalkDir[mapper.walkPosition] ]


		local cmd = dir
	  if (mapper.stepAction) then
			cmd = cmd .. ' &amp; ' .. mapper.stepAction
		end
		mapper.move(cmd)
		map.lastMoveDirection = dir
		return


	else

		if(mapper.paused) then
			echo('\n\n -=[ walking paused ]=-\n\n')
		else
			echo('\n\n -=[ walking disabled ]=-\n\n')
		end

	end -- end if murder is enabled


end


</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>get areaID from TFE Area ID</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function getAreaIdByTfeId (tfeID)

	local areas = getAreaTable()
	 for area, id in pairs(areas) do
		-- deleteArea(id)
    if getAreaUserData(id, "tfe-zone-id") == tfeID then
			-- echo('\nfound existing area! - '.. id .. ' ..\n')
      return id
    end
  end

	if map.mapping then

  	local areaId = addAreaName("NEW: " .. roomInfo.roomName);

		-- in case this area name already exists. bleh
		local inc = 1
		while (not areaId) do
			inc = inc + 1
			areaId = addAreaName("NEW: " .. roomInfo.roomName .. ' - ' .. tostring(inc));
		end

		echo('\nMAPPER: creating new area... ' .. tostring(areaId) .. ' : ' .. tostring(tfeID) .. '\n')


		setAreaUserData(areaId, "tfe-zone-id", tfeID)

  	return areaId
	end


end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>add the current room to map</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function addCurrentRoom ()

  if roomExists(common.roomId) then

		centerview(common.roomId)

  else

		local x = 0; local y = 0; local z = 0;

    -- calculate new x/y/z
  	if common.previousRoomId and roomExists(common.previousRoomId) then
  		-- echo('\n HAD PREVIOUS ROOM!!! - \n' .. common.previousRoomId)
  		x,y,z = getRoomCoordinates(common.previousRoomId);
  		-- echo('\nold location is: ' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')
  		local dx, dy, dz = unpack(map.consts.coordmap[map.consts.stubmap[map.lastMoveDirection]])
  		x = x + dx
  		y = y + dy
  		z = z + dz
  		-- echo('new location is: (' .. tostring(dx) .. ', ' .. tostring(dy) .. ', ' .. tostring(dz) .. ')')
  	end


  	-- echo('moved direction: ' .. map.consts.short[map.lastMoveDirection] )

		echo('\nmap area id is: ' .. map.areaId)

    addRoom(common.roomId)

		setRoomArea(common.roomId, map.areaId);

		-- echo('\nlocation is: (' .. tostring(x) .. ', ' .. tostring(y) .. ', ' .. tostring(z) .. ')\n')

  	-- echo('\nadding room... ' .. common.roomId)

  	setRoomName(common.roomId, roomInfo.roomName)

  	setRoomCoordinates(common.roomId, x, y, z)

		-- add room exit stubs
		for i, exit in ipairs(roomInfo.exits) do
			if(map.consts.short[exit]) then
      	setExitStub(common.roomId, map.consts.short[exit], true)
			end
    end

  	centerview(common.roomId)

  end

	if common.previousRoomId then
		cecho('\n&lt;green&gt;MAPPER: &lt;white&gt;joining ' .. tostring(common.roomId) ..' to room: ' .. tostring(common.previousRoomId))
		setExit(common.previousRoomId, common.roomId, map.consts.stubmap[map.lastMoveDirection])
		setExit(common.roomId, common.previousRoomId, map.consts.stubmap[map.consts.reverse_dirs[map.lastMoveDirection]])
	end



end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>common</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>common</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------

common = common or {}
player = player or {}
roomInfo = roomInfo or {}
group = group or {
	combat = false
}


common.events = {
	PARSED_PROMPT = 'COMMON::parsed_prompt',
	PARSED_EXITS = 'COMMON::parsed_room_exits',
	PARSED_ROOM_INFO = 'COMMON::parsed_room_info',
	PARSED_SCORE = 'COMMON::parsed_score_page',
	PARSED_GROUP = 'COMMON::parsed_group_status',
	PARSED_AFFECTS = 'COMMON::parsed_player_affects',
	PARSED_INVENTORY = 'COMMON:parsed_inventory_contents',
	PARSED_PREPARED = 'COMMON:parsed_prepared_spells',
	PARSED_EQUIPMENT = 'COMMON:parsed_equipment',
	CHANGED_EQUIPMENT = 'COMMON:changed_equipment',
	MOVE_DETECTED = 'COMMON::move_detected',
	ROOM_CHANGED = 'COMMON::room_changed',
	COMBAT_ENDED = 'COMMON::combat_ended',
	COMBAT_STARTED = 'COMMON::combat_started',
	WALK_DONE = 'COMMON::speedwalk_completed',
	ROOM_CLEAR = 'COMMON::current_room_is_clear',
	PARRY_STATE_CHANGE = 'COMMON::parry_state_change',
}

common.tableHasValue =  function (tab, val)
  for index, value in ipairs(tab) do
    if tab[index] == val then
    	return true
    end
  end
  return false
end


common.tfeItemListAdd = function (list, item)
  
	local idx = 0
	local match = nil
	
	-- see if this value is already in the list
	for index, value in ipairs(list) do
		match = rex.match(value, '^(\\d+)?\\*?' .. item .. '$')
    if match ~= nil then
    	idx = index
			break
    end
  end
	
	--  if we found a match, see how many of this item are already in the list
	if (idx &gt; 0) then
		local count = 1
		if (match ~= false) then
			count = tonumber(match)
		end
		count = count + 1
		list[idx] = tostring(count) .. '*' .. item
	else -- this is a new item
		table.insert(list, item)
	end

	return list
end

common.reverseList = function(list)
	
	local i = 1
	local j = #list

	while i &lt; j do
		list[i], list[j] = list[j], list[i]
		i = i + 1
		j = j - 1
	end
	
	return list

end


common.setParryState = function (state, reason, callback, permanent)

	local cb = callback

	player.parryQueue = player.parryQueue or 0
	
	local currentState = player.parry
	
	if (player.parryQueue % 2 == 1) then
		currentState = not currentState
	end
	
		
	if (player.parryRevertTimer) then
		killTimer(player.parryRevertTimer)
		player.parryRevertTimer = nil
	end 

	-- if we are turning parry on, make sure we have a plan to turn it off again
	if (not permanent) then 
		player.parryRevertTimer = tempTimer(15, function ()
			if (player.parry) then
				common.setParryState(false, 'opt parry has been on too long!')
			end
		end)
	end
	

	-- if we need to swap opt parry
	if (currentState ~= state) then	
  
  	cecho('\n&lt;green&gt;PARRY: &lt;white&gt;setting  - ' .. tostring(state) .. ' - ' .. reason or '?' .. '\n')
  	send('opt parry')	
		player.parryQueue = player.parryQueue + 1
  	
  	common.onNextEvent(common.events.PARRY_STATE_CHANGE, function (evt, args)
  		if (cb) then cb() end
    end)
		
	else	
		cecho('\n&lt;green&gt;PARRY: &lt;white&gt;setting  - ' .. tostring(state) .. ' - skipping as no change needed\n')
		if (cb) then cb() end
	end

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>trigger helpers</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------


common.timedTempTrigger = function (timeout, maxTriggerCount, pattern, callback, failcallback)

	local fcb = failcallback
	local ocb = callback

	local cb = function ()
		fcb = nil;
		if (ocb) then
			ocb()
		end
	end


	local triggerId = tempRegexTrigger(pattern, cb, maxTriggerCount)

	local tempTimerId = tempTimer(timeout, function ()
		-- echo('\n -- killing temp timed trigger\n')
		killTrigger(triggerId)
		if (fcb) then
			fcb()
		end
	end, 'timed temp trigger')
	
	return {triggerId = triggerId, timerId = tempTimerId}

end

timedTempTrigger = common.timedTempTrigger


common.onNextEvent = function (evt, callback)

	if not evt then

		echo('no event defined!!!')
		error()

	end


	local handlerId = nil
	local cb2 = callback

	local cb = function (evt, args)
		-- kill the event handler now in case the event errors preventing it's destruction
		killAnonymousEventHandler(handlerId)
		-- cecho('\n&lt;blue&gt;self destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		cb2(evt, args)
	end

	handlerId = registerAnonymousEventHandler(evt, cb, true)

	-- cecho('\n&lt;green&gt;registering self destruct event: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')

	return function ()
		-- cecho('\n&lt;orange&gt;destructing handler: ' .. evt .. ' : ' .. tostring(handlerId) .. '\n')
		killAnonymousEventHandler(handlerId)
	end

end

onNextEvent = common.onNextEvent

common.oneRoomExitTrig = function (direction, code)

  local tempTrigId = tempRegexTrigger('^You see no exit to the (' .. direction .. ')\.$', function ()
		code(matches[2])
	end, 1)

  echo(' &lt;- room sepecific trig: ' .. tostring(tempTrigId))

	-- need to dest these as the first room change will be entering the room where we
	-- want to watch for the event
	common.onNextEvent(common.events.ROOM_CHANGED, function ()
		-- got to wait for a prompt or else this will trigger on the same event as the first
		common.onNextEvent(common.events.PARSED_PROMPT, function ()
      common.onNextEvent(common.events.ROOM_CHANGED, function ()
      	echo('\n ^^ killed room specific trig : '  .. tostring(tempTrigId) .. '\n')
        killTrigger(tempTrigId)
      end)
		end)
	end)

end

oneRoomExitTrig = common.oneRoomExitTrig</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>team</name>
				<packageName></packageName>
				<script>
common.comeToMe = function (callback)

  if (group.memberCount == 1) then
    cecho('\n&lt;yellow&gt;COMMON: &lt;white&gt;skipping regroup due to only one party member\n\n')
    callback()
    return
  end


	local mcb = callback
	local roll = common.newRollCall(true)

	tempTimer(2, function ()

		local atTrig

		local preFetchState = mapper.paused

		mapper.paused = true

  	atTrig = tempRegexTrigger([[^.+ tells the group[^:]*: "(\w+) is now at (\d+)"]], function ()
  		if (tostring(common.roomId) == matches[3]) then

				roll[matches[2]] = true

				if (common.rollCheck(roll)) then
					mapper.paused = preFetchState
					send('gt all here - moving...')
  				killTrigger(atTrig)
  				mcb()
				end

			else
				send('mutter')
				send('gt ' .. matches[2] .. ' go to ' .. tostring(common.roomId))
			end

  	end)

		send('gt meet at ' .. tostring(common.roomId))


	end, 'comeToMe')

end


common.newRollCall = function (excludeSelf)

	local roll = {}
  
  local exludeFromRollCall = { 
    Ghosty = true,
    BatsoFour = true,
  }

	for name, value in pairs(group.members) do
		roll[name] = false
	end
  
  for name, value in pairs(exludeFromRollCall) do
		roll[name] = true
	end

	if (excludeSelf) then
		roll[player.name] = true
	end

	return roll

end

common.rollCheck = function(roll)

	for key, value in pairs(roll) do
		if (not value) then
			return false
		end
	end
	return true

end



common.sendPlayer = function (player, rnum, callback)

	local ncb = callback
	tempRegexTrigger([[^.+ tells the group[^:]*: "]] .. player .. [[ is now at ]] .. tostring(rnum) .. [["]], function ()
		ncb()
	end, 1)

	send('gt ' .. player .. ' go to ' .. tostring(rnum))

end

common.groupOnReady = function (cb)

	local grcb = cb

	local rct

	local roll = common.newRollCall(false)


	local readyCheck = function ()
		if (common.rollCheck(roll)) then -- group members
			killTrigger(rct)
  		if (grcb) then
  			grcb()
  		end
		end
	end

	rct = tempRegexTrigger([[^.* (tells the|tell your) group[^:]*: "ready \((.*)\)"]], function ()
		roll[matches[3]] = true
		readyCheck()
	end)

end

common.groupPrepIfUnder = function (mana, heals, cb)
			
	local pfcb = cb
	
	common.groupOnReady(function ()
		send('gt Going!!!')					
		if (pfcb) then
			pfcb()
		end
	end)

	send('gt prep full if less than ' .. tostring(heals) .. ' cure criticals')
	send('gt get full if under ' .. tostring(mana) .. '% mana')

end

common.groupPrepFull = function (cb)

	local pfcb = cb

	common.groupOnReady(function ()
		send('gt going')
		if (pfcb) then
			pfcb()
		end
	end)

	send('gt get full')

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>debug helpers</name>
				<packageName></packageName>
				<script>-- preserve functions we are about to decorate
oKillTimer = oKillTimer or killTimer
oTempTimer = oTempTimer or tempTimer
oTempRegexTrigger = oTempRegexTrigger or tempRegexTrigger
oTempTrigger = oTempTrigger or tempTrigger

oRaiseEvent = oRaiseEvent or raiseEvent
oRegisterAnonymousEventHandler = oRegisterAnonymousEventHandler or registerAnonymousEventHandler
oKillAnonymousEventHandler = oKillAnonymousEventHandler or killAnonymousEventHandler


eventHandlers = eventHandlers or {}

function registerAnonymousEventHandler(evt, fn, selfDestruct)

	local thisData = {
		handlerId = 0,
		thisEvt = evt,
		lcb = fn,
	}

  local callback
	
	if (type(thisData.lcb) == 'string') then
  		callback =thisData.lcb
			cecho('\n&lt;red&gt;EVENT: &lt;white&gt;event handler defined as string - ' .. thisData.lcb .. ' : ' .. '\n')	
	else
		callback = function (...)
    		local cb = thisData.lcb
    		-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;event handler triggered - ' .. tostring(thisData.handlerId) .. ' : ' .. thisData.thisEvt .. '\n')
				-- display(arg)
    		return cb(unpack(arg))
    	end
	end
	
	thisData.handlerId = oRegisterAnonymousEventHandler(evt, callback, selfDestruct)
	eventHandlers[thisData.handlerId] = evt
	
	return thisData.handlerId
	
end

function killAnonymousEventHandler(id)

	if (eventHandlers[id] ~= nil) then
		-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;killed handler - ' .. tostring(id) .. ' : ' .. eventHandlers[id] .. '\n')
		eventHandlers[id] = nil
	else
		-- cecho('\n&lt;red&gt;TIMER: &lt;white&gt;attempted to kill missing event handler - ' .. id .. '\n')
	end
	
	return oKillAnonymousEventHandler(id)

end

		
-- allow us to track raised events
function raiseEvent(...)
	-- cecho('\n&lt;green&gt;EVENT: &lt;white&gt;raised - ' .. arg[1] .. '\n')
	return oRaiseEvent(unpack(arg))
end

function displayEventHandlers()
	display(eventHandlers)
end


-- triggers

local oKillTrigger = oKillTrigger or killTrigger
tempTriggers = tempTriggers or {}



local wrapTrigger = function (triggerCommand)

	local oCommand = triggerCommand

	return function (regex, code, expireAfter)

  	local trigId = nil
  	local oCode = code
  	local expires = expireAfter

  	local newCode = function (...)

			if (tempTriggers[trigId]) then
      		tempTriggers[trigId].calls = tempTriggers[trigId].calls + 1
      		if (tempTriggers[trigId].calls == expires) then
    	  			tempTriggers[trigId] = nil
      			-- cecho('\n&lt;orange&gt;trigger died of natural causes - ' .. trigId .. ' : ' .. regex .. '\n')
      		end
			end

  		return oCode(...)
  	end

  	trigId = oCommand(regex, newCode, expires)

  	tempTriggers[trigId] = tempTriggers[trigId] or { calls = 0, regex = regex }

  	return trigId
  end


end



tempRegexTrigger = wrapTrigger(oTempRegexTrigger)
tempTrigger = wrapTrigger(oTempTrigger)

killTrigger = function(id)
	if (tempTriggers[id] ) then
		tempTriggers[id] = nil
	end
	return oKillTrigger(id)
end

displayTempTriggers = function()
	display(tempTriggers)
end


-- timers



tempTimers = tempTimers or {}

tempTimer = function(seconds, code, description)

	local timerId

	local oCode = code

	local decoratedCode = function (...)
		-- cecho('\n&lt;green&gt;TIMER: &lt;white&gt;timer ran - ' .. tostring(timerId)  .. ' : ' .. (tempTimers[timerId] or '???') .. '\n')
		-- display(tempTimers)
    -- rabies. next to check if oCode is a string and eval it or something lke that. bleh
		tempTimers[timerId] = nil
    if (type(oCode) == 'string') then
      cecho('\n\nERROR in timer code, not a function: ' .. oCode .. '\n\n')
    end
    
		oCode(...)
	end

	timerId = oTempTimer(seconds, decoratedCode)

	tempTimers[timerId] = (description or 'mystery timer') .. ' - ' .. tostring(seconds) .. ' seconds'

	-- cecho('\n&lt;green&gt;TIMER: &lt;white&gt;timer setup - ' .. tostring(timerId) .. ' : ' .. tempTimers[timerId] .. '\n')

	return timerId

end


killTimer = function(timerId)

	if (tempTimers[timerId] ) then
  	-- cecho('\n&lt;orange&gt;TIMER: &lt;white&gt;killed with fire - ' .. timerId .. ' : ' .. tempTimers[timerId] .. '\n')
  	tempTimers[timerId] = nil
  	oKillTimer(timerId)
	else
		cecho('\n&lt;red&gt;TIMER: &lt;white&gt;attempted to kill missing timer - ' .. timerId .. '\n')
	end
end

displayTempTimers = function()
	display(tempTimers)
end




</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>formatters</name>
				<packageName></packageName>
				<script>
common.consoleMessage = function(console, message, statusColor)

  local color = 'green'
  
  if (statusColor) then 
    color = statusColor 
  end
  
  console:cecho('&lt;' .. color .. '&gt;' .. getTime(true, "hh:mm:ss") .. ': &lt;white&gt;' .. message .. "\n")
end




common.formatElapsedTime = function (time)

	local ts = '';

	if (not time) then
		return '0 seconds'
	end
	
	local hrs = 0
	local mins = 0
	local secs = 0

	if (time &gt;= 3600) then
		hrs = math.floor(time / 3600)
		time = time - (hrs * 3600)
		ts = ts .. tostring(hrs) .. ' hrs, '
	end


	if (time &gt;= 60 or hrs &gt; 0) then
		mins = math.floor(time / 60)
		time = time - (mins * 60)
		ts = ts .. tostring(mins) .. ' mins, '
	end

	secs = math.floor(time)
	time = time - secs
	ts = ts .. tostring(secs) .. ' seconds'


	return ts

end


common.getNumber = function (text)

	local wordToNumberData = {
  	a = 1,
  	an = 1,
  	the = 1,
		one = 1,
		two = 2,
		three = 3,
		four = 4,
		five = 5,
		six = 6,
		seven = 7,
		eight = 8,
		nine = 9,
		ten = 10,
		eleven = 11,
		twelve = 12,
		thrirteen = 13,
		fourteen = 14,
	}

	local numTxt = rex.match(text, [[^\S+]])

	if (numTxt) then
		return wordToNumberData[string.lower(numTxt)] or 1
	else
		-- either it's more than 14 or a proper noun. i.e Stinky (your mount
		return 1
	end

end


common.dotCase = function(string)

	if (not string or string == '') then
		return ''
	end
	return rex.gsub(string, [[\b(the|or|an|a|of|with|and|A|An|The) ]], ''):gsub(' ', '.')
end


common.itemSanitize = function(string)

	if (not string or string == '') then
		return ''
	end
	return rex.gsub(string, [[(empty, |flaming, frost-covered |flaming |frost-covered |labeled |empty |\s\+\d)]], '')
end

common.itemShorten = function(item)

  return rex.gsub(
		rex.gsub(common.dotCase(common.itemSanitize(item)),"'(.*)'",'%1'), 
		'([^.][^.][^.][^.]?)[^.]+', 
		'%1'
	)
	
end

common.commaCase = function (str)
    local extra = #str%3
    if string.sub(str,1,1) == "-" then
        if extra == 0 then
            extra = 3
        else
            extra = extra + 1
        end
    end
    local result = ""
    if extra &gt; 0 then
        result = string.sub(str,1,extra)
        str = string.sub(str,extra+1)
    end
    for w in string.gmatch(str,"%d%d%d") do
        result = result .. "," .. w
    end
    return result:gsub([[^,?]],'')
end



common.toMurderString = function (victim)

	-- remove any articles etc
	victim = rex.gsub(victim, [[\b(a|an|the|good|evil|The|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen)\s]], '')

	-- turn elves back into elf, dwarves etc
	victim = rex.gsub(victim, [[ves$]], 'f')

	-- turn women back to womans
	victim = rex.gsub(victim, [[women\b]], 'woman')

	-- drop i from end (plurals like homonculi
	victim = rex.gsub(victim, [[i\b]], '')



	 -- turn mercenaries back into mercanary
	victim = rex.gsub(victim, [[ies$]], 'y')

	-- dump any s's or es's on the end of a plural  
	-- west : two greater cyclopses, vs a greater cyclops
	-- drudges should go to drudge tho...
	if (rex.find(victim, [[ses\b]])) then
		victim = rex.gsub(victim, [[ses\b]], 's')
	elseif (rex.find(victim, [[es\b]])) then
		victim = rex.gsub(victim, [[es\b]], 'e')
	else
		victim = rex.gsub(victim, [[('?s'?)\b]], '')
	end

	-- dump any random commas
	victim = rex.gsub(victim, [[,]], '')

	-- kill any parts less than 3 charaters
	
	victim = rex.gsub(victim, [[(^|\.|\s)\S\S?(\s|\.|$)]], '%1%2')

	-- kill any extra whitepsace or multiple .'s
	victim = rex.gsub(victim, [[(\s\s+|\.\.+)]], ' ')
	victim = string.trim(victim)

	-- kill any . at start or end.
	victim = rex.gsub(victim, [[^\.]], '')
	victim = rex.gsub(victim, [[\.$]], '')

	return victim

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>check resources</name>
				<packageName></packageName>
				<script>
common.updateStatus = function(callback)
  common.onNextEvent(common.events.PARSED_GROUP, function ()
  	callback()
  end)
	send('group')
end

common.checkFull = function(callback)
	common.checkResources(player.hp_max, player.mp_max, player.moves_max, callback)
end


common.onOffsetReady = function(lessHp, lessMp, lessMoves, callback)

	common.checkResources(player.hp_max - lessHp, player.mp_max - lessMp, player.moves_max - lessMoves, function(readyStatus)
		if(readyStatus) then
			callback()
		else
			tempTimer(10, function ()
				common.onOffsetReady(lessHp, lessMp, lessMoves, callback)
			end, 'on offset ready')
		end
	end)

end


common.onManaReady = function(mana, callback)

	common.checkResources(0, mana, 0, function(readyStatus)
		if(readyStatus) then
			callback()
		else
			tempTimer(10, function ()
				common.onManaReady(mana, callback)
			end, 'on mana ready')
		end
	end)

end


common.checkResources = function(hp, mp, moves, callback)
	common.updateStatus( function ()

		if (player.hp &gt;= hp and player.mp &gt;= mp and player.moves &gt;= moves) then
			echo('\n\n .. READY TO KILL\n')
			callback(true)
		else
			echo('\n\n .. sleep more little tank\n')
			callback(false)
		end
	end)
end


common.onFull = function (callback)

	common.checkFull( function(readyStatus)
		if(readyStatus) then
			callback()
		else
			common.checkFullTimer = tempTimer(10, function ()
				common.checkFullTimer = nil
				common.onFull(callback)
			end, 'on full')
		end
	end)


end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>JSON</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external scripts --
-------------------------------------------------
common = common or {}

--
-- json.lua
--
-- Copyright (c) 2019 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\\\",
  [ "\"" ] = "\\\"",
  [ "\b" ] = "\\b",
  [ "\f" ] = "\\f",
  [ "\n" ] = "\\n",
  [ "\r" ] = "\\r",
  [ "\t" ] = "\\t",
}

local escape_char_map_inv = { [ "\\/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return escape_char_map[c] or string.format("\\u%04x", c:byte())
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val &lt;= -math.huge or val &gt;= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;id=iws-appendixa
  local f = math.floor
  if n &lt;= 0x7f then
    return string.char(n)
  elseif n &lt;= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n &lt;= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n &lt;= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(3, 6),  16 )
  local n2 = tonumber( s:sub(9, 12), 16 )
  -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local has_unicode_escape = false
  local has_surrogate_escape = false
  local has_escape = false
  local last
  for j = i + 1, #str do
    local x = str:byte(j)

    if x &lt; 32 then
      decode_error(str, j, "control character in string")
    end

    if last == 92 then -- "\\" (escape char)
      if x == 117 then -- "u" (unicode escape sequence)
        local hex = str:sub(j + 1, j + 5)
        if not hex:find("%x%x%x%x") then
          decode_error(str, j, "invalid unicode escape in string")
        end
        if hex:find("^[dD][89aAbB]") then
          has_surrogate_escape = true
        else
          has_unicode_escape = true
        end
      else
        local c = string.char(x)
        if not escape_chars[c] then
          decode_error(str, j, "invalid escape char '" .. c .. "' in string")
        end
        has_escape = true
      end
      last = nil

    elseif x == 34 then -- '"' (end of string)
      local s = str:sub(i + 1, j - 1)
      if has_surrogate_escape then
        s = s:gsub("\\u[dD][89aAbB]..\\u....", parse_unicode_escape)
      end
      if has_unicode_escape then
        s = s:gsub("\\u....", parse_unicode_escape)
      end
      if has_escape then
        s = s:gsub("\\.", escape_char_map_inv)
      end
      return s, j + 1

    else
      last = x
    end
  end
  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx &lt;= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end


common.json = json</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
